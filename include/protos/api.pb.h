// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: protos/api.proto
// Protobuf C++ Version: 5.28.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fapi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fapi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protos_2fapi_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fapi_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_protos_2fapi_2eproto;
class AddComponent;
struct AddComponentDefaultTypeInternal;
extern AddComponentDefaultTypeInternal _AddComponent_default_instance_;
class AddVoxels;
struct AddVoxelsDefaultTypeInternal;
extern AddVoxelsDefaultTypeInternal _AddVoxels_default_instance_;
class ApiRequest;
struct ApiRequestDefaultTypeInternal;
extern ApiRequestDefaultTypeInternal _ApiRequest_default_instance_;
class ApiRequestResponse;
struct ApiRequestResponseDefaultTypeInternal;
extern ApiRequestResponseDefaultTypeInternal _ApiRequestResponse_default_instance_;
class ClearVoxels;
struct ClearVoxelsDefaultTypeInternal;
extern ClearVoxelsDefaultTypeInternal _ClearVoxels_default_instance_;
class Component;
struct ComponentDefaultTypeInternal;
extern ComponentDefaultTypeInternal _Component_default_instance_;
class ConfirmAction;
struct ConfirmActionDefaultTypeInternal;
extern ConfirmActionDefaultTypeInternal _ConfirmAction_default_instance_;
class CreateEntity;
struct CreateEntityDefaultTypeInternal;
extern CreateEntityDefaultTypeInternal _CreateEntity_default_instance_;
class DeleteComponent;
struct DeleteComponentDefaultTypeInternal;
extern DeleteComponentDefaultTypeInternal _DeleteComponent_default_instance_;
class DeleteEntity;
struct DeleteEntityDefaultTypeInternal;
extern DeleteEntityDefaultTypeInternal _DeleteEntity_default_instance_;
class EditComponent;
struct EditComponentDefaultTypeInternal;
extern EditComponentDefaultTypeInternal _EditComponent_default_instance_;
class EngineStatus;
struct EngineStatusDefaultTypeInternal;
extern EngineStatusDefaultTypeInternal _EngineStatus_default_instance_;
class EntityComponentInfo;
struct EntityComponentInfoDefaultTypeInternal;
extern EntityComponentInfoDefaultTypeInternal _EntityComponentInfo_default_instance_;
class GetComponent;
struct GetComponentDefaultTypeInternal;
extern GetComponentDefaultTypeInternal _GetComponent_default_instance_;
class KeyReplay;
struct KeyReplayDefaultTypeInternal;
extern KeyReplayDefaultTypeInternal _KeyReplay_default_instance_;
class KeyReplayEntry;
struct KeyReplayEntryDefaultTypeInternal;
extern KeyReplayEntryDefaultTypeInternal _KeyReplayEntry_default_instance_;
class ListEntities;
struct ListEntitiesDefaultTypeInternal;
extern ListEntitiesDefaultTypeInternal _ListEntities_default_instance_;
class LoadURDF;
struct LoadURDFDefaultTypeInternal;
extern LoadURDFDefaultTypeInternal _LoadURDF_default_instance_;
class ModelComponent;
struct ModelComponentDefaultTypeInternal;
extern ModelComponentDefaultTypeInternal _ModelComponent_default_instance_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class NoPayload;
struct NoPayloadDefaultTypeInternal;
extern NoPayloadDefaultTypeInternal _NoPayload_default_instance_;
class PlayerMove;
struct PlayerMoveDefaultTypeInternal;
extern PlayerMoveDefaultTypeInternal _PlayerMove_default_instance_;
class PointerReplay;
struct PointerReplayDefaultTypeInternal;
extern PointerReplayDefaultTypeInternal _PointerReplay_default_instance_;
class PointerReplayEntry;
struct PointerReplayEntryDefaultTypeInternal;
extern PointerReplayEntryDefaultTypeInternal _PointerReplayEntry_default_instance_;
class PositionableComponent;
struct PositionableComponentDefaultTypeInternal;
extern PositionableComponentDefaultTypeInternal _PositionableComponent_default_instance_;
class Range;
struct RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class TurnKey;
struct TurnKeyDefaultTypeInternal;
extern TurnKeyDefaultTypeInternal _TurnKey_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
class VoxelCoord;
struct VoxelCoordDefaultTypeInternal;
extern VoxelCoordDefaultTypeInternal _VoxelCoord_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum MessageType : int {
  MOVE = 0,
  TURN_KEY = 1,
  PLAYER_MOVE = 2,
  UNFOCUS_WINDOW = 3,
  ADD_VOXELS = 4,
  CLEAR_VOXELS = 5,
  CONFIRM_ACTION = 6,
  QUIT = 7,
  KEY_REPLAY = 8,
  STATUS = 9,
  POINTER_REPLAY = 10,
  ADD_COMPONENT = 11,
  DELETE_COMPONENT = 12,
  EDIT_COMPONENT = 13,
  CREATE_ENTITY = 14,
  DELETE_ENTITY = 15,
  LIST_ENTITIES = 16,
  GET_COMPONENT = 17,
  LOAD_URDF = 18,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MessageType_IsValid(int value);
extern const uint32_t MessageType_internal_data_[];
constexpr MessageType MessageType_MIN = static_cast<MessageType>(0);
constexpr MessageType MessageType_MAX = static_cast<MessageType>(18);
constexpr int MessageType_ARRAYSIZE = 18 + 1;
const ::google::protobuf::EnumDescriptor*
MessageType_descriptor();
template <typename T>
const std::string& MessageType_Name(T value) {
  static_assert(std::is_same<T, MessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return MessageType_Name(static_cast<MessageType>(value));
}
template <>
inline const std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MessageType_descriptor,
                                                 0, 18>(
      static_cast<int>(value));
}
inline bool MessageType_Parse(absl::string_view name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
      MessageType_descriptor(), name, value);
}
enum ComponentType : int {
  COMPONENT_TYPE_UNSPECIFIED = 0,
  COMPONENT_TYPE_POSITIONABLE = 1,
  COMPONENT_TYPE_MODEL = 2,
  ComponentType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ComponentType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ComponentType_IsValid(int value);
extern const uint32_t ComponentType_internal_data_[];
constexpr ComponentType ComponentType_MIN = static_cast<ComponentType>(0);
constexpr ComponentType ComponentType_MAX = static_cast<ComponentType>(2);
constexpr int ComponentType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ComponentType_descriptor();
template <typename T>
const std::string& ComponentType_Name(T value) {
  static_assert(std::is_same<T, ComponentType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ComponentType_Name().");
  return ComponentType_Name(static_cast<ComponentType>(value));
}
template <>
inline const std::string& ComponentType_Name(ComponentType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ComponentType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ComponentType_Parse(absl::string_view name, ComponentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComponentType>(
      ComponentType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VoxelCoord final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:VoxelCoord) */ {
 public:
  inline VoxelCoord() : VoxelCoord(nullptr) {}
  ~VoxelCoord() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VoxelCoord(
      ::google::protobuf::internal::ConstantInitialized);

  inline VoxelCoord(const VoxelCoord& from) : VoxelCoord(nullptr, from) {}
  inline VoxelCoord(VoxelCoord&& from) noexcept
      : VoxelCoord(nullptr, std::move(from)) {}
  inline VoxelCoord& operator=(const VoxelCoord& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoxelCoord& operator=(VoxelCoord&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoxelCoord& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoxelCoord* internal_default_instance() {
    return reinterpret_cast<const VoxelCoord*>(
        &_VoxelCoord_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(VoxelCoord& a, VoxelCoord& b) { a.Swap(&b); }
  inline void Swap(VoxelCoord* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoxelCoord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoxelCoord* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<VoxelCoord>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VoxelCoord& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VoxelCoord& from) { VoxelCoord::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VoxelCoord* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "VoxelCoord"; }

 protected:
  explicit VoxelCoord(::google::protobuf::Arena* arena);
  VoxelCoord(::google::protobuf::Arena* arena, const VoxelCoord& from);
  VoxelCoord(::google::protobuf::Arena* arena, VoxelCoord&& from) noexcept
      : VoxelCoord(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:VoxelCoord)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_VoxelCoord_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VoxelCoord& from_msg);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Vector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector(const Vector& from) : Vector(nullptr, from) {}
  inline Vector(Vector&& from) noexcept
      : Vector(nullptr, std::move(from)) {}
  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
        &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Vector& a, Vector& b) { a.Swap(&b); }
  inline void Swap(Vector* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Vector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector& from) { Vector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Vector"; }

 protected:
  explicit Vector(::google::protobuf::Arena* arena);
  Vector(::google::protobuf::Arena* arena, const Vector& from);
  Vector(::google::protobuf::Arena* arena, Vector&& from) noexcept
      : Vector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:Vector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Vector_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector& from_msg);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TurnKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:TurnKey) */ {
 public:
  inline TurnKey() : TurnKey(nullptr) {}
  ~TurnKey() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline TurnKey(const TurnKey& from) : TurnKey(nullptr, from) {}
  inline TurnKey(TurnKey&& from) noexcept
      : TurnKey(nullptr, std::move(from)) {}
  inline TurnKey& operator=(const TurnKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnKey& operator=(TurnKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const TurnKey* internal_default_instance() {
    return reinterpret_cast<const TurnKey*>(
        &_TurnKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(TurnKey& a, TurnKey& b) { a.Swap(&b); }
  inline void Swap(TurnKey* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnKey* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TurnKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnKey& from) { TurnKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TurnKey* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "TurnKey"; }

 protected:
  explicit TurnKey(::google::protobuf::Arena* arena);
  TurnKey(::google::protobuf::Arena* arena, const TurnKey& from);
  TurnKey(::google::protobuf::Arena* arena, TurnKey&& from) noexcept
      : TurnKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOnFieldNumber = 2,
  };
  // bool on = 2;
  void clear_on() ;
  bool on() const;
  void set_on(bool value);

  private:
  bool _internal_on() const;
  void _internal_set_on(bool value);

  public:
  // @@protoc_insertion_point(class_scope:TurnKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TurnKey_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TurnKey& from_msg);
    bool on_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Range final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  ~Range() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Range(
      ::google::protobuf::internal::ConstantInitialized);

  inline Range(const Range& from) : Range(nullptr, from) {}
  inline Range(Range&& from) noexcept
      : Range(nullptr, std::move(from)) {}
  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Range& default_instance() {
    return *internal_default_instance();
  }
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
        &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Range& a, Range& b) { a.Swap(&b); }
  inline void Swap(Range* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Range* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Range>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Range& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Range& from) { Range::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Range* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Range"; }

 protected:
  explicit Range(::google::protobuf::Arena* arena);
  Range(::google::protobuf::Arena* arena, const Range& from);
  Range(::google::protobuf::Arena* arena, Range&& from) noexcept
      : Range(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // float min = 1;
  void clear_min() ;
  float min() const;
  void set_min(float value);

  private:
  float _internal_min() const;
  void _internal_set_min(float value);

  public:
  // float max = 2;
  void clear_max() ;
  float max() const;
  void set_max(float value);

  private:
  float _internal_max() const;
  void _internal_set_max(float value);

  public:
  // @@protoc_insertion_point(class_scope:Range)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Range_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Range& from_msg);
    float min_;
    float max_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PointerReplayEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PointerReplayEntry) */ {
 public:
  inline PointerReplayEntry() : PointerReplayEntry(nullptr) {}
  ~PointerReplayEntry() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointerReplayEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline PointerReplayEntry(const PointerReplayEntry& from) : PointerReplayEntry(nullptr, from) {}
  inline PointerReplayEntry(PointerReplayEntry&& from) noexcept
      : PointerReplayEntry(nullptr, std::move(from)) {}
  inline PointerReplayEntry& operator=(const PointerReplayEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointerReplayEntry& operator=(PointerReplayEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointerReplayEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointerReplayEntry* internal_default_instance() {
    return reinterpret_cast<const PointerReplayEntry*>(
        &_PointerReplayEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PointerReplayEntry& a, PointerReplayEntry& b) { a.Swap(&b); }
  inline void Swap(PointerReplayEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointerReplayEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointerReplayEntry* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PointerReplayEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointerReplayEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointerReplayEntry& from) { PointerReplayEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PointerReplayEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PointerReplayEntry"; }

 protected:
  explicit PointerReplayEntry(::google::protobuf::Arena* arena);
  PointerReplayEntry(::google::protobuf::Arena* arena, const PointerReplayEntry& from);
  PointerReplayEntry(::google::protobuf::Arena* arena, PointerReplayEntry&& from) noexcept
      : PointerReplayEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kButtonFieldNumber = 1,
    kPressedFieldNumber = 2,
    kDelayMsFieldNumber = 3,
  };
  // uint32 button = 1;
  void clear_button() ;
  ::uint32_t button() const;
  void set_button(::uint32_t value);

  private:
  ::uint32_t _internal_button() const;
  void _internal_set_button(::uint32_t value);

  public:
  // bool pressed = 2;
  void clear_pressed() ;
  bool pressed() const;
  void set_pressed(bool value);

  private:
  bool _internal_pressed() const;
  void _internal_set_pressed(bool value);

  public:
  // uint32 delay_ms = 3;
  void clear_delay_ms() ;
  ::uint32_t delay_ms() const;
  void set_delay_ms(::uint32_t value);

  private:
  ::uint32_t _internal_delay_ms() const;
  void _internal_set_delay_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:PointerReplayEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PointerReplayEntry_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PointerReplayEntry& from_msg);
    ::uint32_t button_;
    bool pressed_;
    ::uint32_t delay_ms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class NoPayload final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:NoPayload) */ {
 public:
  inline NoPayload() : NoPayload(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NoPayload(
      ::google::protobuf::internal::ConstantInitialized);

  inline NoPayload(const NoPayload& from) : NoPayload(nullptr, from) {}
  inline NoPayload(NoPayload&& from) noexcept
      : NoPayload(nullptr, std::move(from)) {}
  inline NoPayload& operator=(const NoPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoPayload& operator=(NoPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoPayload* internal_default_instance() {
    return reinterpret_cast<const NoPayload*>(
        &_NoPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NoPayload& a, NoPayload& b) { a.Swap(&b); }
  inline void Swap(NoPayload* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoPayload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoPayload* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<NoPayload>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NoPayload& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NoPayload& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NoPayload"; }

 protected:
  explicit NoPayload(::google::protobuf::Arena* arena);
  NoPayload(::google::protobuf::Arena* arena, const NoPayload& from);
  NoPayload(::google::protobuf::Arena* arena, NoPayload&& from) noexcept
      : NoPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:NoPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NoPayload_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NoPayload& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Move final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Move(
      ::google::protobuf::internal::ConstantInitialized);

  inline Move(const Move& from) : Move(nullptr, from) {}
  inline Move(Move&& from) noexcept
      : Move(nullptr, std::move(from)) {}
  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
        &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(Move& a, Move& b) { a.Swap(&b); }
  inline void Swap(Move* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Move>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Move& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Move& from) { Move::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Move* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Move"; }

 protected:
  explicit Move(::google::protobuf::Arena* arena);
  Move(::google::protobuf::Arena* arena, const Move& from);
  Move(::google::protobuf::Arena* arena, Move&& from) noexcept
      : Move(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXDeltaFieldNumber = 1,
    kYDeltaFieldNumber = 2,
    kZDeltaFieldNumber = 3,
    kUnitsPerSecondFieldNumber = 4,
  };
  // float xDelta = 1;
  void clear_xdelta() ;
  float xdelta() const;
  void set_xdelta(float value);

  private:
  float _internal_xdelta() const;
  void _internal_set_xdelta(float value);

  public:
  // float yDelta = 2;
  void clear_ydelta() ;
  float ydelta() const;
  void set_ydelta(float value);

  private:
  float _internal_ydelta() const;
  void _internal_set_ydelta(float value);

  public:
  // float zDelta = 3;
  void clear_zdelta() ;
  float zdelta() const;
  void set_zdelta(float value);

  private:
  float _internal_zdelta() const;
  void _internal_set_zdelta(float value);

  public:
  // float unitsPerSecond = 4;
  void clear_unitspersecond() ;
  float unitspersecond() const;
  void set_unitspersecond(float value);

  private:
  float _internal_unitspersecond() const;
  void _internal_set_unitspersecond(float value);

  public:
  // @@protoc_insertion_point(class_scope:Move)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Move_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Move& from_msg);
    float xdelta_;
    float ydelta_;
    float zdelta_;
    float unitspersecond_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ModelComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ModelComponent) */ {
 public:
  inline ModelComponent() : ModelComponent(nullptr) {}
  ~ModelComponent() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelComponent(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelComponent(const ModelComponent& from) : ModelComponent(nullptr, from) {}
  inline ModelComponent(ModelComponent&& from) noexcept
      : ModelComponent(nullptr, std::move(from)) {}
  inline ModelComponent& operator=(const ModelComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelComponent& operator=(ModelComponent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelComponent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelComponent* internal_default_instance() {
    return reinterpret_cast<const ModelComponent*>(
        &_ModelComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(ModelComponent& a, ModelComponent& b) { a.Swap(&b); }
  inline void Swap(ModelComponent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelComponent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelComponent* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ModelComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelComponent& from) { ModelComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ModelComponent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ModelComponent"; }

 protected:
  explicit ModelComponent(::google::protobuf::Arena* arena);
  ModelComponent(::google::protobuf::Arena* arena, const ModelComponent& from);
  ModelComponent(::google::protobuf::Arena* arena, ModelComponent&& from) noexcept
      : ModelComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModelPathFieldNumber = 2,
    kEntityIdFieldNumber = 1,
  };
  // string model_path = 2;
  void clear_model_path() ;
  const std::string& model_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_path(Arg_&& arg, Args_... args);
  std::string* mutable_model_path();
  PROTOBUF_NODISCARD std::string* release_model_path();
  void set_allocated_model_path(std::string* value);

  private:
  const std::string& _internal_model_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_path(
      const std::string& value);
  std::string* _internal_mutable_model_path();

  public:
  // int64 entityId = 1;
  void clear_entityid() ;
  ::int64_t entityid() const;
  void set_entityid(::int64_t value);

  private:
  ::int64_t _internal_entityid() const;
  void _internal_set_entityid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ModelComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      33, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ModelComponent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelComponent& from_msg);
    ::google::protobuf::internal::ArenaStringPtr model_path_;
    ::int64_t entityid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ListEntities final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ListEntities) */ {
 public:
  inline ListEntities() : ListEntities(nullptr) {}
  ~ListEntities() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListEntities(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListEntities(const ListEntities& from) : ListEntities(nullptr, from) {}
  inline ListEntities(ListEntities&& from) noexcept
      : ListEntities(nullptr, std::move(from)) {}
  inline ListEntities& operator=(const ListEntities& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEntities& operator=(ListEntities&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEntities& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListEntities* internal_default_instance() {
    return reinterpret_cast<const ListEntities*>(
        &_ListEntities_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ListEntities& a, ListEntities& b) { a.Swap(&b); }
  inline void Swap(ListEntities* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEntities* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEntities* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ListEntities>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListEntities& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListEntities& from) { ListEntities::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListEntities* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ListEntities"; }

 protected:
  explicit ListEntities(::google::protobuf::Arena* arena);
  ListEntities(::google::protobuf::Arena* arena, const ListEntities& from);
  ListEntities(::google::protobuf::Arena* arena, ListEntities&& from) noexcept
      : ListEntities(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilterTypeFieldNumber = 1,
  };
  // .ComponentType filter_type = 1;
  void clear_filter_type() ;
  ::ComponentType filter_type() const;
  void set_filter_type(::ComponentType value);

  private:
  ::ComponentType _internal_filter_type() const;
  void _internal_set_filter_type(::ComponentType value);

  public:
  // @@protoc_insertion_point(class_scope:ListEntities)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ListEntities_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListEntities& from_msg);
    int filter_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class KeyReplayEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:KeyReplayEntry) */ {
 public:
  inline KeyReplayEntry() : KeyReplayEntry(nullptr) {}
  ~KeyReplayEntry() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyReplayEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyReplayEntry(const KeyReplayEntry& from) : KeyReplayEntry(nullptr, from) {}
  inline KeyReplayEntry(KeyReplayEntry&& from) noexcept
      : KeyReplayEntry(nullptr, std::move(from)) {}
  inline KeyReplayEntry& operator=(const KeyReplayEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyReplayEntry& operator=(KeyReplayEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyReplayEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyReplayEntry* internal_default_instance() {
    return reinterpret_cast<const KeyReplayEntry*>(
        &_KeyReplayEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(KeyReplayEntry& a, KeyReplayEntry& b) { a.Swap(&b); }
  inline void Swap(KeyReplayEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyReplayEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyReplayEntry* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<KeyReplayEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyReplayEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyReplayEntry& from) { KeyReplayEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyReplayEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "KeyReplayEntry"; }

 protected:
  explicit KeyReplayEntry(::google::protobuf::Arena* arena);
  KeyReplayEntry(::google::protobuf::Arena* arena, const KeyReplayEntry& from);
  KeyReplayEntry(::google::protobuf::Arena* arena, KeyReplayEntry&& from) noexcept
      : KeyReplayEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymFieldNumber = 1,
    kDelayMsFieldNumber = 2,
  };
  // string sym = 1;
  void clear_sym() ;
  const std::string& sym() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sym(Arg_&& arg, Args_... args);
  std::string* mutable_sym();
  PROTOBUF_NODISCARD std::string* release_sym();
  void set_allocated_sym(std::string* value);

  private:
  const std::string& _internal_sym() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sym(
      const std::string& value);
  std::string* _internal_mutable_sym();

  public:
  // uint32 delay_ms = 2;
  void clear_delay_ms() ;
  ::uint32_t delay_ms() const;
  void set_delay_ms(::uint32_t value);

  private:
  ::uint32_t _internal_delay_ms() const;
  void _internal_set_delay_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:KeyReplayEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      26, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_KeyReplayEntry_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyReplayEntry& from_msg);
    ::google::protobuf::internal::ArenaStringPtr sym_;
    ::uint32_t delay_ms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class GetComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GetComponent) */ {
 public:
  inline GetComponent() : GetComponent(nullptr) {}
  ~GetComponent() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetComponent(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetComponent(const GetComponent& from) : GetComponent(nullptr, from) {}
  inline GetComponent(GetComponent&& from) noexcept
      : GetComponent(nullptr, std::move(from)) {}
  inline GetComponent& operator=(const GetComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetComponent& operator=(GetComponent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetComponent& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetComponent* internal_default_instance() {
    return reinterpret_cast<const GetComponent*>(
        &_GetComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GetComponent& a, GetComponent& b) { a.Swap(&b); }
  inline void Swap(GetComponent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetComponent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetComponent* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetComponent& from) { GetComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetComponent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GetComponent"; }

 protected:
  explicit GetComponent(::google::protobuf::Arena* arena);
  GetComponent(::google::protobuf::Arena* arena, const GetComponent& from);
  GetComponent(::google::protobuf::Arena* arena, GetComponent&& from) noexcept
      : GetComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentTypeFieldNumber = 1,
  };
  // .ComponentType component_type = 1;
  void clear_component_type() ;
  ::ComponentType component_type() const;
  void set_component_type(::ComponentType value);

  private:
  ::ComponentType _internal_component_type() const;
  void _internal_set_component_type(::ComponentType value);

  public:
  // @@protoc_insertion_point(class_scope:GetComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetComponent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetComponent& from_msg);
    int component_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EntityComponentInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:EntityComponentInfo) */ {
 public:
  inline EntityComponentInfo() : EntityComponentInfo(nullptr) {}
  ~EntityComponentInfo() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityComponentInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntityComponentInfo(const EntityComponentInfo& from) : EntityComponentInfo(nullptr, from) {}
  inline EntityComponentInfo(EntityComponentInfo&& from) noexcept
      : EntityComponentInfo(nullptr, std::move(from)) {}
  inline EntityComponentInfo& operator=(const EntityComponentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityComponentInfo& operator=(EntityComponentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityComponentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityComponentInfo* internal_default_instance() {
    return reinterpret_cast<const EntityComponentInfo*>(
        &_EntityComponentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(EntityComponentInfo& a, EntityComponentInfo& b) { a.Swap(&b); }
  inline void Swap(EntityComponentInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityComponentInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityComponentInfo* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<EntityComponentInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityComponentInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntityComponentInfo& from) { EntityComponentInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntityComponentInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "EntityComponentInfo"; }

 protected:
  explicit EntityComponentInfo(::google::protobuf::Arena* arena);
  EntityComponentInfo(::google::protobuf::Arena* arena, const EntityComponentInfo& from);
  EntityComponentInfo(::google::protobuf::Arena* arena, EntityComponentInfo&& from) noexcept
      : EntityComponentInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentTypesFieldNumber = 2,
    kEntityIdFieldNumber = 1,
  };
  // repeated .ComponentType component_types = 2;
  int component_types_size() const;
  private:
  int _internal_component_types_size() const;

  public:
  void clear_component_types() ;
  public:
  ::ComponentType component_types(int index) const;
  void set_component_types(int index, ::ComponentType value);
  void add_component_types(::ComponentType value);
  const ::google::protobuf::RepeatedField<int>& component_types() const;
  ::google::protobuf::RepeatedField<int>* mutable_component_types();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_component_types() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_component_types();

  public:
  // int64 entity_id = 1;
  void clear_entity_id() ;
  ::int64_t entity_id() const;
  void set_entity_id(::int64_t value);

  private:
  ::int64_t _internal_entity_id() const;
  void _internal_set_entity_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:EntityComponentInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EntityComponentInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EntityComponentInfo& from_msg);
    ::google::protobuf::RepeatedField<int> component_types_;
    mutable ::google::protobuf::internal::CachedSize _component_types_cached_byte_size_;
    ::int64_t entity_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteEntity final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DeleteEntity) */ {
 public:
  inline DeleteEntity() : DeleteEntity(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteEntity(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteEntity(const DeleteEntity& from) : DeleteEntity(nullptr, from) {}
  inline DeleteEntity(DeleteEntity&& from) noexcept
      : DeleteEntity(nullptr, std::move(from)) {}
  inline DeleteEntity& operator=(const DeleteEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteEntity& operator=(DeleteEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteEntity* internal_default_instance() {
    return reinterpret_cast<const DeleteEntity*>(
        &_DeleteEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(DeleteEntity& a, DeleteEntity& b) { a.Swap(&b); }
  inline void Swap(DeleteEntity* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteEntity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteEntity* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeleteEntity>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteEntity& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteEntity& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DeleteEntity"; }

 protected:
  explicit DeleteEntity(::google::protobuf::Arena* arena);
  DeleteEntity(::google::protobuf::Arena* arena, const DeleteEntity& from);
  DeleteEntity(::google::protobuf::Arena* arena, DeleteEntity&& from) noexcept
      : DeleteEntity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DeleteEntity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DeleteEntity_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteEntity& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DeleteComponent) */ {
 public:
  inline DeleteComponent() : DeleteComponent(nullptr) {}
  ~DeleteComponent() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteComponent(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteComponent(const DeleteComponent& from) : DeleteComponent(nullptr, from) {}
  inline DeleteComponent(DeleteComponent&& from) noexcept
      : DeleteComponent(nullptr, std::move(from)) {}
  inline DeleteComponent& operator=(const DeleteComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteComponent& operator=(DeleteComponent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteComponent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteComponent* internal_default_instance() {
    return reinterpret_cast<const DeleteComponent*>(
        &_DeleteComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(DeleteComponent& a, DeleteComponent& b) { a.Swap(&b); }
  inline void Swap(DeleteComponent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteComponent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteComponent* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DeleteComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteComponent& from) { DeleteComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeleteComponent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DeleteComponent"; }

 protected:
  explicit DeleteComponent(::google::protobuf::Arena* arena);
  DeleteComponent(::google::protobuf::Arena* arena, const DeleteComponent& from);
  DeleteComponent(::google::protobuf::Arena* arena, DeleteComponent&& from) noexcept
      : DeleteComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentTypeFieldNumber = 1,
  };
  // .ComponentType component_type = 1;
  void clear_component_type() ;
  ::ComponentType component_type() const;
  void set_component_type(::ComponentType value);

  private:
  ::ComponentType _internal_component_type() const;
  void _internal_set_component_type(::ComponentType value);

  public:
  // @@protoc_insertion_point(class_scope:DeleteComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DeleteComponent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteComponent& from_msg);
    int component_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateEntity final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:CreateEntity) */ {
 public:
  inline CreateEntity() : CreateEntity(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateEntity(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateEntity(const CreateEntity& from) : CreateEntity(nullptr, from) {}
  inline CreateEntity(CreateEntity&& from) noexcept
      : CreateEntity(nullptr, std::move(from)) {}
  inline CreateEntity& operator=(const CreateEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEntity& operator=(CreateEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateEntity* internal_default_instance() {
    return reinterpret_cast<const CreateEntity*>(
        &_CreateEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(CreateEntity& a, CreateEntity& b) { a.Swap(&b); }
  inline void Swap(CreateEntity* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEntity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateEntity* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CreateEntity>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateEntity& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateEntity& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CreateEntity"; }

 protected:
  explicit CreateEntity(::google::protobuf::Arena* arena);
  CreateEntity(::google::protobuf::Arena* arena, const CreateEntity& from);
  CreateEntity(::google::protobuf::Arena* arena, CreateEntity&& from) noexcept
      : CreateEntity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:CreateEntity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CreateEntity_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateEntity& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ConfirmAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ConfirmAction) */ {
 public:
  inline ConfirmAction() : ConfirmAction(nullptr) {}
  ~ConfirmAction() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConfirmAction(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConfirmAction(const ConfirmAction& from) : ConfirmAction(nullptr, from) {}
  inline ConfirmAction(ConfirmAction&& from) noexcept
      : ConfirmAction(nullptr, std::move(from)) {}
  inline ConfirmAction& operator=(const ConfirmAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmAction& operator=(ConfirmAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmAction* internal_default_instance() {
    return reinterpret_cast<const ConfirmAction*>(
        &_ConfirmAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ConfirmAction& a, ConfirmAction& b) { a.Swap(&b); }
  inline void Swap(ConfirmAction* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmAction* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ConfirmAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConfirmAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConfirmAction& from) { ConfirmAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConfirmAction* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ConfirmAction"; }

 protected:
  explicit ConfirmAction(::google::protobuf::Arena* arena);
  ConfirmAction(::google::protobuf::Arena* arena, const ConfirmAction& from);
  ConfirmAction(::google::protobuf::Arena* arena, ConfirmAction&& from) noexcept
      : ConfirmAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionIdFieldNumber = 1,
  };
  // int64 actionId = 1;
  void clear_actionid() ;
  ::int64_t actionid() const;
  void set_actionid(::int64_t value);

  private:
  ::int64_t _internal_actionid() const;
  void _internal_set_actionid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ConfirmAction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ConfirmAction_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConfirmAction& from_msg);
    ::int64_t actionid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PositionableComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PositionableComponent) */ {
 public:
  inline PositionableComponent() : PositionableComponent(nullptr) {}
  ~PositionableComponent() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionableComponent(
      ::google::protobuf::internal::ConstantInitialized);

  inline PositionableComponent(const PositionableComponent& from) : PositionableComponent(nullptr, from) {}
  inline PositionableComponent(PositionableComponent&& from) noexcept
      : PositionableComponent(nullptr, std::move(from)) {}
  inline PositionableComponent& operator=(const PositionableComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionableComponent& operator=(PositionableComponent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionableComponent& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionableComponent* internal_default_instance() {
    return reinterpret_cast<const PositionableComponent*>(
        &_PositionableComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(PositionableComponent& a, PositionableComponent& b) { a.Swap(&b); }
  inline void Swap(PositionableComponent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionableComponent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionableComponent* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PositionableComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionableComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionableComponent& from) { PositionableComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PositionableComponent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PositionableComponent"; }

 protected:
  explicit PositionableComponent(::google::protobuf::Arena* arena);
  PositionableComponent(::google::protobuf::Arena* arena, const PositionableComponent& from);
  PositionableComponent(::google::protobuf::Arena* arena, PositionableComponent&& from) noexcept
      : PositionableComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kOriginFieldNumber = 5,
    kEntityIdFieldNumber = 1,
    kScaleFieldNumber = 4,
  };
  // .Vector position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::Vector& position() const;
  PROTOBUF_NODISCARD ::Vector* release_position();
  ::Vector* mutable_position();
  void set_allocated_position(::Vector* value);
  void unsafe_arena_set_allocated_position(::Vector* value);
  ::Vector* unsafe_arena_release_position();

  private:
  const ::Vector& _internal_position() const;
  ::Vector* _internal_mutable_position();

  public:
  // .Vector rotation = 3;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::Vector& rotation() const;
  PROTOBUF_NODISCARD ::Vector* release_rotation();
  ::Vector* mutable_rotation();
  void set_allocated_rotation(::Vector* value);
  void unsafe_arena_set_allocated_rotation(::Vector* value);
  ::Vector* unsafe_arena_release_rotation();

  private:
  const ::Vector& _internal_rotation() const;
  ::Vector* _internal_mutable_rotation();

  public:
  // .Vector origin = 5;
  bool has_origin() const;
  void clear_origin() ;
  const ::Vector& origin() const;
  PROTOBUF_NODISCARD ::Vector* release_origin();
  ::Vector* mutable_origin();
  void set_allocated_origin(::Vector* value);
  void unsafe_arena_set_allocated_origin(::Vector* value);
  ::Vector* unsafe_arena_release_origin();

  private:
  const ::Vector& _internal_origin() const;
  ::Vector* _internal_mutable_origin();

  public:
  // int64 entityId = 1;
  void clear_entityid() ;
  ::int64_t entityid() const;
  void set_entityid(::int64_t value);

  private:
  ::int64_t _internal_entityid() const;
  void _internal_set_entityid(::int64_t value);

  public:
  // float scale = 4;
  void clear_scale() ;
  float scale() const;
  void set_scale(float value);

  private:
  float _internal_scale() const;
  void _internal_set_scale(float value);

  public:
  // @@protoc_insertion_point(class_scope:PositionableComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PositionableComponent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PositionableComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Vector* position_;
    ::Vector* rotation_;
    ::Vector* origin_;
    ::int64_t entityid_;
    float scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PointerReplay final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PointerReplay) */ {
 public:
  inline PointerReplay() : PointerReplay(nullptr) {}
  ~PointerReplay() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointerReplay(
      ::google::protobuf::internal::ConstantInitialized);

  inline PointerReplay(const PointerReplay& from) : PointerReplay(nullptr, from) {}
  inline PointerReplay(PointerReplay&& from) noexcept
      : PointerReplay(nullptr, std::move(from)) {}
  inline PointerReplay& operator=(const PointerReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointerReplay& operator=(PointerReplay&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointerReplay& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointerReplay* internal_default_instance() {
    return reinterpret_cast<const PointerReplay*>(
        &_PointerReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PointerReplay& a, PointerReplay& b) { a.Swap(&b); }
  inline void Swap(PointerReplay* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointerReplay* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointerReplay* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PointerReplay>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointerReplay& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointerReplay& from) { PointerReplay::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PointerReplay* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PointerReplay"; }

 protected:
  explicit PointerReplay(::google::protobuf::Arena* arena);
  PointerReplay(::google::protobuf::Arena* arena, const PointerReplay& from);
  PointerReplay(::google::protobuf::Arena* arena, PointerReplay&& from) noexcept
      : PointerReplay(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .PointerReplayEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::PointerReplayEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* _internal_mutable_entries();
  public:
  const ::PointerReplayEntry& entries(int index) const;
  ::PointerReplayEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>& entries() const;
  // @@protoc_insertion_point(class_scope:PointerReplay)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PointerReplay_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PointerReplay& from_msg);
    ::google::protobuf::RepeatedPtrField< ::PointerReplayEntry > entries_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PlayerMove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerMove) */ {
 public:
  inline PlayerMove() : PlayerMove(nullptr) {}
  ~PlayerMove() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerMove(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerMove(const PlayerMove& from) : PlayerMove(nullptr, from) {}
  inline PlayerMove(PlayerMove&& from) noexcept
      : PlayerMove(nullptr, std::move(from)) {}
  inline PlayerMove& operator=(const PlayerMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMove& operator=(PlayerMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMove* internal_default_instance() {
    return reinterpret_cast<const PlayerMove*>(
        &_PlayerMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PlayerMove& a, PlayerMove& b) { a.Swap(&b); }
  inline void Swap(PlayerMove* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMove* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PlayerMove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerMove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerMove& from) { PlayerMove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerMove* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlayerMove"; }

 protected:
  explicit PlayerMove(::google::protobuf::Arena* arena);
  PlayerMove(::google::protobuf::Arena* arena, const PlayerMove& from);
  PlayerMove(::google::protobuf::Arena* arena, PlayerMove&& from) noexcept
      : PlayerMove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
    kUnitsPerSecondFieldNumber = 3,
  };
  // .Vector position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::Vector& position() const;
  PROTOBUF_NODISCARD ::Vector* release_position();
  ::Vector* mutable_position();
  void set_allocated_position(::Vector* value);
  void unsafe_arena_set_allocated_position(::Vector* value);
  ::Vector* unsafe_arena_release_position();

  private:
  const ::Vector& _internal_position() const;
  ::Vector* _internal_mutable_position();

  public:
  // .Vector rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::Vector& rotation() const;
  PROTOBUF_NODISCARD ::Vector* release_rotation();
  ::Vector* mutable_rotation();
  void set_allocated_rotation(::Vector* value);
  void unsafe_arena_set_allocated_rotation(::Vector* value);
  ::Vector* unsafe_arena_release_rotation();

  private:
  const ::Vector& _internal_rotation() const;
  ::Vector* _internal_mutable_rotation();

  public:
  // float unitsPerSecond = 3;
  void clear_unitspersecond() ;
  float unitspersecond() const;
  void set_unitspersecond(float value);

  private:
  float _internal_unitspersecond() const;
  void _internal_set_unitspersecond(float value);

  public:
  // @@protoc_insertion_point(class_scope:PlayerMove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerMove_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerMove& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Vector* position_;
    ::Vector* rotation_;
    float unitspersecond_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class LoadURDF final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:LoadURDF) */ {
 public:
  inline LoadURDF() : LoadURDF(nullptr) {}
  ~LoadURDF() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadURDF(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoadURDF(const LoadURDF& from) : LoadURDF(nullptr, from) {}
  inline LoadURDF(LoadURDF&& from) noexcept
      : LoadURDF(nullptr, std::move(from)) {}
  inline LoadURDF& operator=(const LoadURDF& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadURDF& operator=(LoadURDF&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadURDF& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadURDF* internal_default_instance() {
    return reinterpret_cast<const LoadURDF*>(
        &_LoadURDF_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(LoadURDF& a, LoadURDF& b) { a.Swap(&b); }
  inline void Swap(LoadURDF* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadURDF* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadURDF* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<LoadURDF>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoadURDF& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoadURDF& from) { LoadURDF::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadURDF* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "LoadURDF"; }

 protected:
  explicit LoadURDF(::google::protobuf::Arena* arena);
  LoadURDF(::google::protobuf::Arena* arena, const LoadURDF& from);
  LoadURDF(::google::protobuf::Arena* arena, LoadURDF&& from) noexcept
      : LoadURDF(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUrdfPathFieldNumber = 1,
    kInitialPositionFieldNumber = 2,
  };
  // string urdf_path = 1;
  void clear_urdf_path() ;
  const std::string& urdf_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_urdf_path(Arg_&& arg, Args_... args);
  std::string* mutable_urdf_path();
  PROTOBUF_NODISCARD std::string* release_urdf_path();
  void set_allocated_urdf_path(std::string* value);

  private:
  const std::string& _internal_urdf_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_urdf_path(
      const std::string& value);
  std::string* _internal_mutable_urdf_path();

  public:
  // .Vector initial_position = 2;
  bool has_initial_position() const;
  void clear_initial_position() ;
  const ::Vector& initial_position() const;
  PROTOBUF_NODISCARD ::Vector* release_initial_position();
  ::Vector* mutable_initial_position();
  void set_allocated_initial_position(::Vector* value);
  void unsafe_arena_set_allocated_initial_position(::Vector* value);
  ::Vector* unsafe_arena_release_initial_position();

  private:
  const ::Vector& _internal_initial_position() const;
  ::Vector* _internal_mutable_initial_position();

  public:
  // @@protoc_insertion_point(class_scope:LoadURDF)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      26, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LoadURDF_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoadURDF& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr urdf_path_;
    ::Vector* initial_position_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class KeyReplay final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:KeyReplay) */ {
 public:
  inline KeyReplay() : KeyReplay(nullptr) {}
  ~KeyReplay() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyReplay(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyReplay(const KeyReplay& from) : KeyReplay(nullptr, from) {}
  inline KeyReplay(KeyReplay&& from) noexcept
      : KeyReplay(nullptr, std::move(from)) {}
  inline KeyReplay& operator=(const KeyReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyReplay& operator=(KeyReplay&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyReplay& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyReplay* internal_default_instance() {
    return reinterpret_cast<const KeyReplay*>(
        &_KeyReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(KeyReplay& a, KeyReplay& b) { a.Swap(&b); }
  inline void Swap(KeyReplay* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyReplay* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyReplay* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<KeyReplay>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyReplay& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyReplay& from) { KeyReplay::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyReplay* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "KeyReplay"; }

 protected:
  explicit KeyReplay(::google::protobuf::Arena* arena);
  KeyReplay(::google::protobuf::Arena* arena, const KeyReplay& from);
  KeyReplay(::google::protobuf::Arena* arena, KeyReplay&& from) noexcept
      : KeyReplay(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .KeyReplayEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::KeyReplayEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* _internal_mutable_entries();
  public:
  const ::KeyReplayEntry& entries(int index) const;
  ::KeyReplayEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>& entries() const;
  // @@protoc_insertion_point(class_scope:KeyReplay)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_KeyReplay_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyReplay& from_msg);
    ::google::protobuf::RepeatedPtrField< ::KeyReplayEntry > entries_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EngineStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:EngineStatus) */ {
 public:
  inline EngineStatus() : EngineStatus(nullptr) {}
  ~EngineStatus() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EngineStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline EngineStatus(const EngineStatus& from) : EngineStatus(nullptr, from) {}
  inline EngineStatus(EngineStatus&& from) noexcept
      : EngineStatus(nullptr, std::move(from)) {}
  inline EngineStatus& operator=(const EngineStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineStatus& operator=(EngineStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineStatus* internal_default_instance() {
    return reinterpret_cast<const EngineStatus*>(
        &_EngineStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(EngineStatus& a, EngineStatus& b) { a.Swap(&b); }
  inline void Swap(EngineStatus* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineStatus* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<EngineStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EngineStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EngineStatus& from) { EngineStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EngineStatus* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "EngineStatus"; }

 protected:
  explicit EngineStatus(::google::protobuf::Arena* arena);
  EngineStatus(::google::protobuf::Arena* arena, const EngineStatus& from);
  EngineStatus(::google::protobuf::Arena* arena, EngineStatus&& from) noexcept
      : EngineStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCameraPositionFieldNumber = 4,
    kTotalEntitiesFieldNumber = 1,
    kWaylandAppsFieldNumber = 2,
    kWaylandFocusFieldNumber = 3,
  };
  // .Vector camera_position = 4;
  bool has_camera_position() const;
  void clear_camera_position() ;
  const ::Vector& camera_position() const;
  PROTOBUF_NODISCARD ::Vector* release_camera_position();
  ::Vector* mutable_camera_position();
  void set_allocated_camera_position(::Vector* value);
  void unsafe_arena_set_allocated_camera_position(::Vector* value);
  ::Vector* unsafe_arena_release_camera_position();

  private:
  const ::Vector& _internal_camera_position() const;
  ::Vector* _internal_mutable_camera_position();

  public:
  // uint32 total_entities = 1;
  void clear_total_entities() ;
  ::uint32_t total_entities() const;
  void set_total_entities(::uint32_t value);

  private:
  ::uint32_t _internal_total_entities() const;
  void _internal_set_total_entities(::uint32_t value);

  public:
  // uint32 wayland_apps = 2;
  void clear_wayland_apps() ;
  ::uint32_t wayland_apps() const;
  void set_wayland_apps(::uint32_t value);

  private:
  ::uint32_t _internal_wayland_apps() const;
  void _internal_set_wayland_apps(::uint32_t value);

  public:
  // bool wayland_focus = 3;
  void clear_wayland_focus() ;
  bool wayland_focus() const;
  void set_wayland_focus(bool value);

  private:
  bool _internal_wayland_focus() const;
  void _internal_set_wayland_focus(bool value);

  public:
  // @@protoc_insertion_point(class_scope:EngineStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EngineStatus_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EngineStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Vector* camera_position_;
    ::uint32_t total_entities_;
    ::uint32_t wayland_apps_;
    bool wayland_focus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ClearVoxels final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ClearVoxels) */ {
 public:
  inline ClearVoxels() : ClearVoxels(nullptr) {}
  ~ClearVoxels() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClearVoxels(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClearVoxels(const ClearVoxels& from) : ClearVoxels(nullptr, from) {}
  inline ClearVoxels(ClearVoxels&& from) noexcept
      : ClearVoxels(nullptr, std::move(from)) {}
  inline ClearVoxels& operator=(const ClearVoxels& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearVoxels& operator=(ClearVoxels&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearVoxels& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearVoxels* internal_default_instance() {
    return reinterpret_cast<const ClearVoxels*>(
        &_ClearVoxels_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ClearVoxels& a, ClearVoxels& b) { a.Swap(&b); }
  inline void Swap(ClearVoxels* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearVoxels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearVoxels* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ClearVoxels>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClearVoxels& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClearVoxels& from) { ClearVoxels::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClearVoxels* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ClearVoxels"; }

 protected:
  explicit ClearVoxels(::google::protobuf::Arena* arena);
  ClearVoxels(::google::protobuf::Arena* arena, const ClearVoxels& from);
  ClearVoxels(::google::protobuf::Arena* arena, ClearVoxels&& from) noexcept
      : ClearVoxels(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .Range x = 1;
  bool has_x() const;
  void clear_x() ;
  const ::Range& x() const;
  PROTOBUF_NODISCARD ::Range* release_x();
  ::Range* mutable_x();
  void set_allocated_x(::Range* value);
  void unsafe_arena_set_allocated_x(::Range* value);
  ::Range* unsafe_arena_release_x();

  private:
  const ::Range& _internal_x() const;
  ::Range* _internal_mutable_x();

  public:
  // .Range y = 2;
  bool has_y() const;
  void clear_y() ;
  const ::Range& y() const;
  PROTOBUF_NODISCARD ::Range* release_y();
  ::Range* mutable_y();
  void set_allocated_y(::Range* value);
  void unsafe_arena_set_allocated_y(::Range* value);
  ::Range* unsafe_arena_release_y();

  private:
  const ::Range& _internal_y() const;
  ::Range* _internal_mutable_y();

  public:
  // .Range z = 3;
  bool has_z() const;
  void clear_z() ;
  const ::Range& z() const;
  PROTOBUF_NODISCARD ::Range* release_z();
  ::Range* mutable_z();
  void set_allocated_z(::Range* value);
  void unsafe_arena_set_allocated_z(::Range* value);
  ::Range* unsafe_arena_release_z();

  private:
  const ::Range& _internal_z() const;
  ::Range* _internal_mutable_z();

  public:
  // @@protoc_insertion_point(class_scope:ClearVoxels)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ClearVoxels_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClearVoxels& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Range* x_;
    ::Range* y_;
    ::Range* z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class AddVoxels final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AddVoxels) */ {
 public:
  inline AddVoxels() : AddVoxels(nullptr) {}
  ~AddVoxels() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddVoxels(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddVoxels(const AddVoxels& from) : AddVoxels(nullptr, from) {}
  inline AddVoxels(AddVoxels&& from) noexcept
      : AddVoxels(nullptr, std::move(from)) {}
  inline AddVoxels& operator=(const AddVoxels& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddVoxels& operator=(AddVoxels&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddVoxels& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddVoxels* internal_default_instance() {
    return reinterpret_cast<const AddVoxels*>(
        &_AddVoxels_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(AddVoxels& a, AddVoxels& b) { a.Swap(&b); }
  inline void Swap(AddVoxels* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddVoxels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddVoxels* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AddVoxels>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddVoxels& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddVoxels& from) { AddVoxels::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddVoxels* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "AddVoxels"; }

 protected:
  explicit AddVoxels(::google::protobuf::Arena* arena);
  AddVoxels(::google::protobuf::Arena* arena, const AddVoxels& from);
  AddVoxels(::google::protobuf::Arena* arena, AddVoxels&& from) noexcept
      : AddVoxels(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVoxelsFieldNumber = 1,
    kColorFieldNumber = 4,
    kReplaceFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // repeated .VoxelCoord voxels = 1;
  int voxels_size() const;
  private:
  int _internal_voxels_size() const;

  public:
  void clear_voxels() ;
  ::VoxelCoord* mutable_voxels(int index);
  ::google::protobuf::RepeatedPtrField<::VoxelCoord>* mutable_voxels();

  private:
  const ::google::protobuf::RepeatedPtrField<::VoxelCoord>& _internal_voxels() const;
  ::google::protobuf::RepeatedPtrField<::VoxelCoord>* _internal_mutable_voxels();
  public:
  const ::VoxelCoord& voxels(int index) const;
  ::VoxelCoord* add_voxels();
  const ::google::protobuf::RepeatedPtrField<::VoxelCoord>& voxels() const;
  // .Vector color = 4;
  bool has_color() const;
  void clear_color() ;
  const ::Vector& color() const;
  PROTOBUF_NODISCARD ::Vector* release_color();
  ::Vector* mutable_color();
  void set_allocated_color(::Vector* value);
  void unsafe_arena_set_allocated_color(::Vector* value);
  ::Vector* unsafe_arena_release_color();

  private:
  const ::Vector& _internal_color() const;
  ::Vector* _internal_mutable_color();

  public:
  // bool replace = 2;
  void clear_replace() ;
  bool replace() const;
  void set_replace(bool value);

  private:
  bool _internal_replace() const;
  void _internal_set_replace(bool value);

  public:
  // float size = 3;
  void clear_size() ;
  float size() const;
  void set_size(float value);

  private:
  float _internal_size() const;
  void _internal_set_size(float value);

  public:
  // @@protoc_insertion_point(class_scope:AddVoxels)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AddVoxels_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AddVoxels& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::VoxelCoord > voxels_;
    ::Vector* color_;
    bool replace_;
    float size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Component final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Component) */ {
 public:
  inline Component() : Component(nullptr) {}
  ~Component() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Component(
      ::google::protobuf::internal::ConstantInitialized);

  inline Component(const Component& from) : Component(nullptr, from) {}
  inline Component(Component&& from) noexcept
      : Component(nullptr, std::move(from)) {}
  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }
  inline Component& operator=(Component&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Component& default_instance() {
    return *internal_default_instance();
  }
  enum ComponentTypeCase {
    kPositionable = 2,
    kModel = 3,
    COMPONENT_TYPE_NOT_SET = 0,
  };
  static inline const Component* internal_default_instance() {
    return reinterpret_cast<const Component*>(
        &_Component_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(Component& a, Component& b) { a.Swap(&b); }
  inline void Swap(Component* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Component* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Component* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Component>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Component& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Component& from) { Component::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Component* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Component"; }

 protected:
  explicit Component(::google::protobuf::Arena* arena);
  Component(::google::protobuf::Arena* arena, const Component& from);
  Component(::google::protobuf::Arena* arena, Component&& from) noexcept
      : Component(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kPositionableFieldNumber = 2,
    kModelFieldNumber = 3,
  };
  // .ComponentType type = 1;
  void clear_type() ;
  ::ComponentType type() const;
  void set_type(::ComponentType value);

  private:
  ::ComponentType _internal_type() const;
  void _internal_set_type(::ComponentType value);

  public:
  // .PositionableComponent positionable = 2;
  bool has_positionable() const;
  private:
  bool _internal_has_positionable() const;

  public:
  void clear_positionable() ;
  const ::PositionableComponent& positionable() const;
  PROTOBUF_NODISCARD ::PositionableComponent* release_positionable();
  ::PositionableComponent* mutable_positionable();
  void set_allocated_positionable(::PositionableComponent* value);
  void unsafe_arena_set_allocated_positionable(::PositionableComponent* value);
  ::PositionableComponent* unsafe_arena_release_positionable();

  private:
  const ::PositionableComponent& _internal_positionable() const;
  ::PositionableComponent* _internal_mutable_positionable();

  public:
  // .ModelComponent model = 3;
  bool has_model() const;
  private:
  bool _internal_has_model() const;

  public:
  void clear_model() ;
  const ::ModelComponent& model() const;
  PROTOBUF_NODISCARD ::ModelComponent* release_model();
  ::ModelComponent* mutable_model();
  void set_allocated_model(::ModelComponent* value);
  void unsafe_arena_set_allocated_model(::ModelComponent* value);
  ::ModelComponent* unsafe_arena_release_model();

  private:
  const ::ModelComponent& _internal_model() const;
  ::ModelComponent* _internal_mutable_model();

  public:
  void clear_component_type();
  ComponentTypeCase component_type_case() const;
  // @@protoc_insertion_point(class_scope:Component)
 private:
  class _Internal;
  void set_has_positionable();
  void set_has_model();
  inline bool has_component_type() const;
  inline void clear_has_component_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Component_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Component& from_msg);
    int type_;
    union ComponentTypeUnion {
      constexpr ComponentTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::PositionableComponent* positionable_;
      ::ModelComponent* model_;
    } component_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EditComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:EditComponent) */ {
 public:
  inline EditComponent() : EditComponent(nullptr) {}
  ~EditComponent() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EditComponent(
      ::google::protobuf::internal::ConstantInitialized);

  inline EditComponent(const EditComponent& from) : EditComponent(nullptr, from) {}
  inline EditComponent(EditComponent&& from) noexcept
      : EditComponent(nullptr, std::move(from)) {}
  inline EditComponent& operator=(const EditComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditComponent& operator=(EditComponent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditComponent& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditComponent* internal_default_instance() {
    return reinterpret_cast<const EditComponent*>(
        &_EditComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(EditComponent& a, EditComponent& b) { a.Swap(&b); }
  inline void Swap(EditComponent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditComponent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditComponent* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<EditComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EditComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EditComponent& from) { EditComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EditComponent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "EditComponent"; }

 protected:
  explicit EditComponent(::google::protobuf::Arena* arena);
  EditComponent(::google::protobuf::Arena* arena, const EditComponent& from);
  EditComponent(::google::protobuf::Arena* arena, EditComponent&& from) noexcept
      : EditComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentFieldNumber = 1,
  };
  // .Component component = 1;
  bool has_component() const;
  void clear_component() ;
  const ::Component& component() const;
  PROTOBUF_NODISCARD ::Component* release_component();
  ::Component* mutable_component();
  void set_allocated_component(::Component* value);
  void unsafe_arena_set_allocated_component(::Component* value);
  ::Component* unsafe_arena_release_component();

  private:
  const ::Component& _internal_component() const;
  ::Component* _internal_mutable_component();

  public:
  // @@protoc_insertion_point(class_scope:EditComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EditComponent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EditComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Component* component_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ApiRequestResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ApiRequestResponse) */ {
 public:
  inline ApiRequestResponse() : ApiRequestResponse(nullptr) {}
  ~ApiRequestResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApiRequestResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApiRequestResponse(const ApiRequestResponse& from) : ApiRequestResponse(nullptr, from) {}
  inline ApiRequestResponse(ApiRequestResponse&& from) noexcept
      : ApiRequestResponse(nullptr, std::move(from)) {}
  inline ApiRequestResponse& operator=(const ApiRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiRequestResponse& operator=(ApiRequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiRequestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiRequestResponse* internal_default_instance() {
    return reinterpret_cast<const ApiRequestResponse*>(
        &_ApiRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(ApiRequestResponse& a, ApiRequestResponse& b) { a.Swap(&b); }
  inline void Swap(ApiRequestResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiRequestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiRequestResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ApiRequestResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApiRequestResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApiRequestResponse& from) { ApiRequestResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ApiRequestResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ApiRequestResponse"; }

 protected:
  explicit ApiRequestResponse(::google::protobuf::Arena* arena);
  ApiRequestResponse(::google::protobuf::Arena* arena, const ApiRequestResponse& from);
  ApiRequestResponse(::google::protobuf::Arena* arena, ApiRequestResponse&& from) noexcept
      : ApiRequestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdsFieldNumber = 5,
    kEntityComponentsFieldNumber = 7,
    kStatusFieldNumber = 4,
    kComponentFieldNumber = 6,
    kRequestIdFieldNumber = 1,
    kActionIdFieldNumber = 2,
    kSuccessFieldNumber = 3,
  };
  // repeated int64 entity_ids = 5;
  int entity_ids_size() const;
  private:
  int _internal_entity_ids_size() const;

  public:
  void clear_entity_ids() ;
  ::int64_t entity_ids(int index) const;
  void set_entity_ids(int index, ::int64_t value);
  void add_entity_ids(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& entity_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_entity_ids();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_entity_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_entity_ids();

  public:
  // repeated .EntityComponentInfo entity_components = 7;
  int entity_components_size() const;
  private:
  int _internal_entity_components_size() const;

  public:
  void clear_entity_components() ;
  ::EntityComponentInfo* mutable_entity_components(int index);
  ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>* mutable_entity_components();

  private:
  const ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>& _internal_entity_components() const;
  ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>* _internal_mutable_entity_components();
  public:
  const ::EntityComponentInfo& entity_components(int index) const;
  ::EntityComponentInfo* add_entity_components();
  const ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>& entity_components() const;
  // .EngineStatus status = 4;
  bool has_status() const;
  void clear_status() ;
  const ::EngineStatus& status() const;
  PROTOBUF_NODISCARD ::EngineStatus* release_status();
  ::EngineStatus* mutable_status();
  void set_allocated_status(::EngineStatus* value);
  void unsafe_arena_set_allocated_status(::EngineStatus* value);
  ::EngineStatus* unsafe_arena_release_status();

  private:
  const ::EngineStatus& _internal_status() const;
  ::EngineStatus* _internal_mutable_status();

  public:
  // .Component component = 6;
  bool has_component() const;
  void clear_component() ;
  const ::Component& component() const;
  PROTOBUF_NODISCARD ::Component* release_component();
  ::Component* mutable_component();
  void set_allocated_component(::Component* value);
  void unsafe_arena_set_allocated_component(::Component* value);
  ::Component* unsafe_arena_release_component();

  private:
  const ::Component& _internal_component() const;
  ::Component* _internal_mutable_component();

  public:
  // int64 requestId = 1;
  void clear_requestid() ;
  ::int64_t requestid() const;
  void set_requestid(::int64_t value);

  private:
  ::int64_t _internal_requestid() const;
  void _internal_set_requestid(::int64_t value);

  public:
  // int64 actionId = 2;
  void clear_actionid() ;
  ::int64_t actionid() const;
  void set_actionid(::int64_t value);

  private:
  ::int64_t _internal_actionid() const;
  void _internal_set_actionid(::int64_t value);

  public:
  // bool success = 3;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ApiRequestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ApiRequestResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApiRequestResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> entity_ids_;
    mutable ::google::protobuf::internal::CachedSize _entity_ids_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::EntityComponentInfo > entity_components_;
    ::EngineStatus* status_;
    ::Component* component_;
    ::int64_t requestid_;
    ::int64_t actionid_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class AddComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AddComponent) */ {
 public:
  inline AddComponent() : AddComponent(nullptr) {}
  ~AddComponent() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddComponent(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddComponent(const AddComponent& from) : AddComponent(nullptr, from) {}
  inline AddComponent(AddComponent&& from) noexcept
      : AddComponent(nullptr, std::move(from)) {}
  inline AddComponent& operator=(const AddComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddComponent& operator=(AddComponent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddComponent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddComponent* internal_default_instance() {
    return reinterpret_cast<const AddComponent*>(
        &_AddComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(AddComponent& a, AddComponent& b) { a.Swap(&b); }
  inline void Swap(AddComponent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddComponent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddComponent* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AddComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddComponent& from) { AddComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddComponent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "AddComponent"; }

 protected:
  explicit AddComponent(::google::protobuf::Arena* arena);
  AddComponent(::google::protobuf::Arena* arena, const AddComponent& from);
  AddComponent(::google::protobuf::Arena* arena, AddComponent&& from) noexcept
      : AddComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentFieldNumber = 1,
  };
  // .Component component = 1;
  bool has_component() const;
  void clear_component() ;
  const ::Component& component() const;
  PROTOBUF_NODISCARD ::Component* release_component();
  ::Component* mutable_component();
  void set_allocated_component(::Component* value);
  void unsafe_arena_set_allocated_component(::Component* value);
  ::Component* unsafe_arena_release_component();

  private:
  const ::Component& _internal_component() const;
  ::Component* _internal_mutable_component();

  public:
  // @@protoc_insertion_point(class_scope:AddComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AddComponent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AddComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Component* component_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ApiRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ApiRequest) */ {
 public:
  inline ApiRequest() : ApiRequest(nullptr) {}
  ~ApiRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApiRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApiRequest(const ApiRequest& from) : ApiRequest(nullptr, from) {}
  inline ApiRequest(ApiRequest&& from) noexcept
      : ApiRequest(nullptr, std::move(from)) {}
  inline ApiRequest& operator=(const ApiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiRequest& operator=(ApiRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiRequest& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kMove = 3,
    kTurnKey = 4,
    kPlayerMove = 5,
    kNoPayload = 6,
    kAddVoxels = 7,
    kClearVoxels = 8,
    kConfirmAction = 9,
    kKeyReplay = 10,
    kPointerReplay = 11,
    kAddComponent = 12,
    kDeleteComponent = 13,
    kEditComponent = 14,
    kCreateEntity = 15,
    kDeleteEntity = 16,
    kListEntities = 17,
    kGetComponent = 18,
    kLoadUrdf = 19,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const ApiRequest* internal_default_instance() {
    return reinterpret_cast<const ApiRequest*>(
        &_ApiRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ApiRequest& a, ApiRequest& b) { a.Swap(&b); }
  inline void Swap(ApiRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ApiRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApiRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApiRequest& from) { ApiRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ApiRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ApiRequest"; }

 protected:
  explicit ApiRequest(::google::protobuf::Arena* arena);
  ApiRequest(::google::protobuf::Arena* arena, const ApiRequest& from);
  ApiRequest(::google::protobuf::Arena* arena, ApiRequest&& from) noexcept
      : ApiRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kMoveFieldNumber = 3,
    kTurnKeyFieldNumber = 4,
    kPlayerMoveFieldNumber = 5,
    kNoPayloadFieldNumber = 6,
    kAddVoxelsFieldNumber = 7,
    kClearVoxelsFieldNumber = 8,
    kConfirmActionFieldNumber = 9,
    kKeyReplayFieldNumber = 10,
    kPointerReplayFieldNumber = 11,
    kAddComponentFieldNumber = 12,
    kDeleteComponentFieldNumber = 13,
    kEditComponentFieldNumber = 14,
    kCreateEntityFieldNumber = 15,
    kDeleteEntityFieldNumber = 16,
    kListEntitiesFieldNumber = 17,
    kGetComponentFieldNumber = 18,
    kLoadUrdfFieldNumber = 19,
  };
  // int64 entityId = 1;
  void clear_entityid() ;
  ::int64_t entityid() const;
  void set_entityid(::int64_t value);

  private:
  ::int64_t _internal_entityid() const;
  void _internal_set_entityid(::int64_t value);

  public:
  // .MessageType type = 2;
  void clear_type() ;
  ::MessageType type() const;
  void set_type(::MessageType value);

  private:
  ::MessageType _internal_type() const;
  void _internal_set_type(::MessageType value);

  public:
  // .Move move = 3;
  bool has_move() const;
  private:
  bool _internal_has_move() const;

  public:
  void clear_move() ;
  const ::Move& move() const;
  PROTOBUF_NODISCARD ::Move* release_move();
  ::Move* mutable_move();
  void set_allocated_move(::Move* value);
  void unsafe_arena_set_allocated_move(::Move* value);
  ::Move* unsafe_arena_release_move();

  private:
  const ::Move& _internal_move() const;
  ::Move* _internal_mutable_move();

  public:
  // .TurnKey turnKey = 4;
  bool has_turnkey() const;
  private:
  bool _internal_has_turnkey() const;

  public:
  void clear_turnkey() ;
  const ::TurnKey& turnkey() const;
  PROTOBUF_NODISCARD ::TurnKey* release_turnkey();
  ::TurnKey* mutable_turnkey();
  void set_allocated_turnkey(::TurnKey* value);
  void unsafe_arena_set_allocated_turnkey(::TurnKey* value);
  ::TurnKey* unsafe_arena_release_turnkey();

  private:
  const ::TurnKey& _internal_turnkey() const;
  ::TurnKey* _internal_mutable_turnkey();

  public:
  // .PlayerMove playerMove = 5;
  bool has_playermove() const;
  private:
  bool _internal_has_playermove() const;

  public:
  void clear_playermove() ;
  const ::PlayerMove& playermove() const;
  PROTOBUF_NODISCARD ::PlayerMove* release_playermove();
  ::PlayerMove* mutable_playermove();
  void set_allocated_playermove(::PlayerMove* value);
  void unsafe_arena_set_allocated_playermove(::PlayerMove* value);
  ::PlayerMove* unsafe_arena_release_playermove();

  private:
  const ::PlayerMove& _internal_playermove() const;
  ::PlayerMove* _internal_mutable_playermove();

  public:
  // .NoPayload noPayload = 6;
  bool has_nopayload() const;
  private:
  bool _internal_has_nopayload() const;

  public:
  void clear_nopayload() ;
  const ::NoPayload& nopayload() const;
  PROTOBUF_NODISCARD ::NoPayload* release_nopayload();
  ::NoPayload* mutable_nopayload();
  void set_allocated_nopayload(::NoPayload* value);
  void unsafe_arena_set_allocated_nopayload(::NoPayload* value);
  ::NoPayload* unsafe_arena_release_nopayload();

  private:
  const ::NoPayload& _internal_nopayload() const;
  ::NoPayload* _internal_mutable_nopayload();

  public:
  // .AddVoxels addVoxels = 7;
  bool has_addvoxels() const;
  private:
  bool _internal_has_addvoxels() const;

  public:
  void clear_addvoxels() ;
  const ::AddVoxels& addvoxels() const;
  PROTOBUF_NODISCARD ::AddVoxels* release_addvoxels();
  ::AddVoxels* mutable_addvoxels();
  void set_allocated_addvoxels(::AddVoxels* value);
  void unsafe_arena_set_allocated_addvoxels(::AddVoxels* value);
  ::AddVoxels* unsafe_arena_release_addvoxels();

  private:
  const ::AddVoxels& _internal_addvoxels() const;
  ::AddVoxels* _internal_mutable_addvoxels();

  public:
  // .ClearVoxels clearVoxels = 8;
  bool has_clearvoxels() const;
  private:
  bool _internal_has_clearvoxels() const;

  public:
  void clear_clearvoxels() ;
  const ::ClearVoxels& clearvoxels() const;
  PROTOBUF_NODISCARD ::ClearVoxels* release_clearvoxels();
  ::ClearVoxels* mutable_clearvoxels();
  void set_allocated_clearvoxels(::ClearVoxels* value);
  void unsafe_arena_set_allocated_clearvoxels(::ClearVoxels* value);
  ::ClearVoxels* unsafe_arena_release_clearvoxels();

  private:
  const ::ClearVoxels& _internal_clearvoxels() const;
  ::ClearVoxels* _internal_mutable_clearvoxels();

  public:
  // .ConfirmAction confirmAction = 9;
  bool has_confirmaction() const;
  private:
  bool _internal_has_confirmaction() const;

  public:
  void clear_confirmaction() ;
  const ::ConfirmAction& confirmaction() const;
  PROTOBUF_NODISCARD ::ConfirmAction* release_confirmaction();
  ::ConfirmAction* mutable_confirmaction();
  void set_allocated_confirmaction(::ConfirmAction* value);
  void unsafe_arena_set_allocated_confirmaction(::ConfirmAction* value);
  ::ConfirmAction* unsafe_arena_release_confirmaction();

  private:
  const ::ConfirmAction& _internal_confirmaction() const;
  ::ConfirmAction* _internal_mutable_confirmaction();

  public:
  // .KeyReplay keyReplay = 10;
  bool has_keyreplay() const;
  private:
  bool _internal_has_keyreplay() const;

  public:
  void clear_keyreplay() ;
  const ::KeyReplay& keyreplay() const;
  PROTOBUF_NODISCARD ::KeyReplay* release_keyreplay();
  ::KeyReplay* mutable_keyreplay();
  void set_allocated_keyreplay(::KeyReplay* value);
  void unsafe_arena_set_allocated_keyreplay(::KeyReplay* value);
  ::KeyReplay* unsafe_arena_release_keyreplay();

  private:
  const ::KeyReplay& _internal_keyreplay() const;
  ::KeyReplay* _internal_mutable_keyreplay();

  public:
  // .PointerReplay pointerReplay = 11;
  bool has_pointerreplay() const;
  private:
  bool _internal_has_pointerreplay() const;

  public:
  void clear_pointerreplay() ;
  const ::PointerReplay& pointerreplay() const;
  PROTOBUF_NODISCARD ::PointerReplay* release_pointerreplay();
  ::PointerReplay* mutable_pointerreplay();
  void set_allocated_pointerreplay(::PointerReplay* value);
  void unsafe_arena_set_allocated_pointerreplay(::PointerReplay* value);
  ::PointerReplay* unsafe_arena_release_pointerreplay();

  private:
  const ::PointerReplay& _internal_pointerreplay() const;
  ::PointerReplay* _internal_mutable_pointerreplay();

  public:
  // .AddComponent addComponent = 12;
  bool has_addcomponent() const;
  private:
  bool _internal_has_addcomponent() const;

  public:
  void clear_addcomponent() ;
  const ::AddComponent& addcomponent() const;
  PROTOBUF_NODISCARD ::AddComponent* release_addcomponent();
  ::AddComponent* mutable_addcomponent();
  void set_allocated_addcomponent(::AddComponent* value);
  void unsafe_arena_set_allocated_addcomponent(::AddComponent* value);
  ::AddComponent* unsafe_arena_release_addcomponent();

  private:
  const ::AddComponent& _internal_addcomponent() const;
  ::AddComponent* _internal_mutable_addcomponent();

  public:
  // .DeleteComponent deleteComponent = 13;
  bool has_deletecomponent() const;
  private:
  bool _internal_has_deletecomponent() const;

  public:
  void clear_deletecomponent() ;
  const ::DeleteComponent& deletecomponent() const;
  PROTOBUF_NODISCARD ::DeleteComponent* release_deletecomponent();
  ::DeleteComponent* mutable_deletecomponent();
  void set_allocated_deletecomponent(::DeleteComponent* value);
  void unsafe_arena_set_allocated_deletecomponent(::DeleteComponent* value);
  ::DeleteComponent* unsafe_arena_release_deletecomponent();

  private:
  const ::DeleteComponent& _internal_deletecomponent() const;
  ::DeleteComponent* _internal_mutable_deletecomponent();

  public:
  // .EditComponent editComponent = 14;
  bool has_editcomponent() const;
  private:
  bool _internal_has_editcomponent() const;

  public:
  void clear_editcomponent() ;
  const ::EditComponent& editcomponent() const;
  PROTOBUF_NODISCARD ::EditComponent* release_editcomponent();
  ::EditComponent* mutable_editcomponent();
  void set_allocated_editcomponent(::EditComponent* value);
  void unsafe_arena_set_allocated_editcomponent(::EditComponent* value);
  ::EditComponent* unsafe_arena_release_editcomponent();

  private:
  const ::EditComponent& _internal_editcomponent() const;
  ::EditComponent* _internal_mutable_editcomponent();

  public:
  // .CreateEntity createEntity = 15;
  bool has_createentity() const;
  private:
  bool _internal_has_createentity() const;

  public:
  void clear_createentity() ;
  const ::CreateEntity& createentity() const;
  PROTOBUF_NODISCARD ::CreateEntity* release_createentity();
  ::CreateEntity* mutable_createentity();
  void set_allocated_createentity(::CreateEntity* value);
  void unsafe_arena_set_allocated_createentity(::CreateEntity* value);
  ::CreateEntity* unsafe_arena_release_createentity();

  private:
  const ::CreateEntity& _internal_createentity() const;
  ::CreateEntity* _internal_mutable_createentity();

  public:
  // .DeleteEntity deleteEntity = 16;
  bool has_deleteentity() const;
  private:
  bool _internal_has_deleteentity() const;

  public:
  void clear_deleteentity() ;
  const ::DeleteEntity& deleteentity() const;
  PROTOBUF_NODISCARD ::DeleteEntity* release_deleteentity();
  ::DeleteEntity* mutable_deleteentity();
  void set_allocated_deleteentity(::DeleteEntity* value);
  void unsafe_arena_set_allocated_deleteentity(::DeleteEntity* value);
  ::DeleteEntity* unsafe_arena_release_deleteentity();

  private:
  const ::DeleteEntity& _internal_deleteentity() const;
  ::DeleteEntity* _internal_mutable_deleteentity();

  public:
  // .ListEntities listEntities = 17;
  bool has_listentities() const;
  private:
  bool _internal_has_listentities() const;

  public:
  void clear_listentities() ;
  const ::ListEntities& listentities() const;
  PROTOBUF_NODISCARD ::ListEntities* release_listentities();
  ::ListEntities* mutable_listentities();
  void set_allocated_listentities(::ListEntities* value);
  void unsafe_arena_set_allocated_listentities(::ListEntities* value);
  ::ListEntities* unsafe_arena_release_listentities();

  private:
  const ::ListEntities& _internal_listentities() const;
  ::ListEntities* _internal_mutable_listentities();

  public:
  // .GetComponent getComponent = 18;
  bool has_getcomponent() const;
  private:
  bool _internal_has_getcomponent() const;

  public:
  void clear_getcomponent() ;
  const ::GetComponent& getcomponent() const;
  PROTOBUF_NODISCARD ::GetComponent* release_getcomponent();
  ::GetComponent* mutable_getcomponent();
  void set_allocated_getcomponent(::GetComponent* value);
  void unsafe_arena_set_allocated_getcomponent(::GetComponent* value);
  ::GetComponent* unsafe_arena_release_getcomponent();

  private:
  const ::GetComponent& _internal_getcomponent() const;
  ::GetComponent* _internal_mutable_getcomponent();

  public:
  // .LoadURDF loadUrdf = 19;
  bool has_loadurdf() const;
  private:
  bool _internal_has_loadurdf() const;

  public:
  void clear_loadurdf() ;
  const ::LoadURDF& loadurdf() const;
  PROTOBUF_NODISCARD ::LoadURDF* release_loadurdf();
  ::LoadURDF* mutable_loadurdf();
  void set_allocated_loadurdf(::LoadURDF* value);
  void unsafe_arena_set_allocated_loadurdf(::LoadURDF* value);
  ::LoadURDF* unsafe_arena_release_loadurdf();

  private:
  const ::LoadURDF& _internal_loadurdf() const;
  ::LoadURDF* _internal_mutable_loadurdf();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ApiRequest)
 private:
  class _Internal;
  void set_has_move();
  void set_has_turnkey();
  void set_has_playermove();
  void set_has_nopayload();
  void set_has_addvoxels();
  void set_has_clearvoxels();
  void set_has_confirmaction();
  void set_has_keyreplay();
  void set_has_pointerreplay();
  void set_has_addcomponent();
  void set_has_deletecomponent();
  void set_has_editcomponent();
  void set_has_createentity();
  void set_has_deleteentity();
  void set_has_listentities();
  void set_has_getcomponent();
  void set_has_loadurdf();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 19, 17,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ApiRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApiRequest& from_msg);
    ::int64_t entityid_;
    int type_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::Move* move_;
      ::TurnKey* turnkey_;
      ::PlayerMove* playermove_;
      ::NoPayload* nopayload_;
      ::AddVoxels* addvoxels_;
      ::ClearVoxels* clearvoxels_;
      ::ConfirmAction* confirmaction_;
      ::KeyReplay* keyreplay_;
      ::PointerReplay* pointerreplay_;
      ::AddComponent* addcomponent_;
      ::DeleteComponent* deletecomponent_;
      ::EditComponent* editcomponent_;
      ::CreateEntity* createentity_;
      ::DeleteEntity* deleteentity_;
      ::ListEntities* listentities_;
      ::GetComponent* getcomponent_;
      ::LoadURDF* loadurdf_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NoPayload

// -------------------------------------------------------------------

// Vector

// float x = 1;
inline void Vector::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Vector::x() const {
  // @@protoc_insertion_point(field_get:Vector.x)
  return _internal_x();
}
inline void Vector::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Vector.x)
}
inline float Vector::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Vector::y() const {
  // @@protoc_insertion_point(field_get:Vector.y)
  return _internal_y();
}
inline void Vector::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Vector.y)
}
inline float Vector::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Vector::z() const {
  // @@protoc_insertion_point(field_get:Vector.z)
  return _internal_z();
}
inline void Vector::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Vector.z)
}
inline float Vector::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vector::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Range

// float min = 1;
inline void Range::clear_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = 0;
}
inline float Range::min() const {
  // @@protoc_insertion_point(field_get:Range.min)
  return _internal_min();
}
inline void Range::set_min(float value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:Range.min)
}
inline float Range::_internal_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_;
}
inline void Range::_internal_set_min(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = value;
}

// float max = 2;
inline void Range::clear_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = 0;
}
inline float Range::max() const {
  // @@protoc_insertion_point(field_get:Range.max)
  return _internal_max();
}
inline void Range::set_max(float value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:Range.max)
}
inline float Range::_internal_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_;
}
inline void Range::_internal_set_max(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = value;
}

// -------------------------------------------------------------------

// PlayerMove

// .Vector position = 1;
inline bool PlayerMove::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void PlayerMove::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Vector& PlayerMove::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PlayerMove::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMove.position)
  return _internal_position();
}
inline void PlayerMove::unsafe_arena_set_allocated_position(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMove.position)
}
inline ::Vector* PlayerMove::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* PlayerMove::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlayerMove.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Vector* PlayerMove::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.position_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.position_;
}
inline ::Vector* PlayerMove::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Vector* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:PlayerMove.position)
  return _msg;
}
inline void PlayerMove::set_allocated_position(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMove.position)
}

// .Vector rotation = 2;
inline bool PlayerMove::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void PlayerMove::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Vector& PlayerMove::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PlayerMove::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMove.rotation)
  return _internal_rotation();
}
inline void PlayerMove::unsafe_arena_set_allocated_rotation(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMove.rotation)
}
inline ::Vector* PlayerMove::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Vector* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* PlayerMove::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlayerMove.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Vector* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Vector* PlayerMove::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.rotation_;
}
inline ::Vector* PlayerMove::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Vector* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:PlayerMove.rotation)
  return _msg;
}
inline void PlayerMove::set_allocated_rotation(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMove.rotation)
}

// float unitsPerSecond = 3;
inline void PlayerMove::clear_unitspersecond() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = 0;
}
inline float PlayerMove::unitspersecond() const {
  // @@protoc_insertion_point(field_get:PlayerMove.unitsPerSecond)
  return _internal_unitspersecond();
}
inline void PlayerMove::set_unitspersecond(float value) {
  _internal_set_unitspersecond(value);
  // @@protoc_insertion_point(field_set:PlayerMove.unitsPerSecond)
}
inline float PlayerMove::_internal_unitspersecond() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unitspersecond_;
}
inline void PlayerMove::_internal_set_unitspersecond(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = value;
}

// -------------------------------------------------------------------

// VoxelCoord

// float x = 1;
inline void VoxelCoord::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float VoxelCoord::x() const {
  // @@protoc_insertion_point(field_get:VoxelCoord.x)
  return _internal_x();
}
inline void VoxelCoord::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:VoxelCoord.x)
}
inline float VoxelCoord::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void VoxelCoord::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void VoxelCoord::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float VoxelCoord::y() const {
  // @@protoc_insertion_point(field_get:VoxelCoord.y)
  return _internal_y();
}
inline void VoxelCoord::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:VoxelCoord.y)
}
inline float VoxelCoord::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void VoxelCoord::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void VoxelCoord::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float VoxelCoord::z() const {
  // @@protoc_insertion_point(field_get:VoxelCoord.z)
  return _internal_z();
}
inline void VoxelCoord::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:VoxelCoord.z)
}
inline float VoxelCoord::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void VoxelCoord::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// AddVoxels

// repeated .VoxelCoord voxels = 1;
inline int AddVoxels::_internal_voxels_size() const {
  return _internal_voxels().size();
}
inline int AddVoxels::voxels_size() const {
  return _internal_voxels_size();
}
inline void AddVoxels::clear_voxels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.voxels_.Clear();
}
inline ::VoxelCoord* AddVoxels::mutable_voxels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:AddVoxels.voxels)
  return _internal_mutable_voxels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::VoxelCoord>* AddVoxels::mutable_voxels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:AddVoxels.voxels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_voxels();
}
inline const ::VoxelCoord& AddVoxels::voxels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AddVoxels.voxels)
  return _internal_voxels().Get(index);
}
inline ::VoxelCoord* AddVoxels::add_voxels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::VoxelCoord* _add = _internal_mutable_voxels()->Add();
  // @@protoc_insertion_point(field_add:AddVoxels.voxels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::VoxelCoord>& AddVoxels::voxels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:AddVoxels.voxels)
  return _internal_voxels();
}
inline const ::google::protobuf::RepeatedPtrField<::VoxelCoord>&
AddVoxels::_internal_voxels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.voxels_;
}
inline ::google::protobuf::RepeatedPtrField<::VoxelCoord>*
AddVoxels::_internal_mutable_voxels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.voxels_;
}

// bool replace = 2;
inline void AddVoxels::clear_replace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replace_ = false;
}
inline bool AddVoxels::replace() const {
  // @@protoc_insertion_point(field_get:AddVoxels.replace)
  return _internal_replace();
}
inline void AddVoxels::set_replace(bool value) {
  _internal_set_replace(value);
  // @@protoc_insertion_point(field_set:AddVoxels.replace)
}
inline bool AddVoxels::_internal_replace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replace_;
}
inline void AddVoxels::_internal_set_replace(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replace_ = value;
}

// float size = 3;
inline void AddVoxels::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
}
inline float AddVoxels::size() const {
  // @@protoc_insertion_point(field_get:AddVoxels.size)
  return _internal_size();
}
inline void AddVoxels::set_size(float value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:AddVoxels.size)
}
inline float AddVoxels::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void AddVoxels::_internal_set_size(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// .Vector color = 4;
inline bool AddVoxels::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void AddVoxels::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Vector& AddVoxels::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& AddVoxels::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AddVoxels.color)
  return _internal_color();
}
inline void AddVoxels::unsafe_arena_set_allocated_color(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AddVoxels.color)
}
inline ::Vector* AddVoxels::release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* AddVoxels::unsafe_arena_release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AddVoxels.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Vector* AddVoxels::_internal_mutable_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.color_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.color_;
}
inline ::Vector* AddVoxels::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Vector* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:AddVoxels.color)
  return _msg;
}
inline void AddVoxels::set_allocated_color(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:AddVoxels.color)
}

// -------------------------------------------------------------------

// ClearVoxels

// .Range x = 1;
inline bool ClearVoxels::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline void ClearVoxels::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Range& ClearVoxels::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Range* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::Range&>(::_Range_default_instance_);
}
inline const ::Range& ClearVoxels::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClearVoxels.x)
  return _internal_x();
}
inline void ClearVoxels::unsafe_arena_set_allocated_x(::Range* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClearVoxels.x)
}
inline ::Range* ClearVoxels::release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Range* released = _impl_.x_;
  _impl_.x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Range* ClearVoxels::unsafe_arena_release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClearVoxels.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Range* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::Range* ClearVoxels::_internal_mutable_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Range>(GetArena());
    _impl_.x_ = reinterpret_cast<::Range*>(p);
  }
  return _impl_.x_;
}
inline ::Range* ClearVoxels::mutable_x() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Range* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:ClearVoxels.x)
  return _msg;
}
inline void ClearVoxels::set_allocated_x(::Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClearVoxels.x)
}

// .Range y = 2;
inline bool ClearVoxels::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline void ClearVoxels::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Range& ClearVoxels::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Range* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::Range&>(::_Range_default_instance_);
}
inline const ::Range& ClearVoxels::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClearVoxels.y)
  return _internal_y();
}
inline void ClearVoxels::unsafe_arena_set_allocated_y(::Range* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClearVoxels.y)
}
inline ::Range* ClearVoxels::release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Range* released = _impl_.y_;
  _impl_.y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Range* ClearVoxels::unsafe_arena_release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClearVoxels.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Range* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::Range* ClearVoxels::_internal_mutable_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Range>(GetArena());
    _impl_.y_ = reinterpret_cast<::Range*>(p);
  }
  return _impl_.y_;
}
inline ::Range* ClearVoxels::mutable_y() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Range* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:ClearVoxels.y)
  return _msg;
}
inline void ClearVoxels::set_allocated_y(::Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClearVoxels.y)
}

// .Range z = 3;
inline bool ClearVoxels::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline void ClearVoxels::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Range& ClearVoxels::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Range* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::Range&>(::_Range_default_instance_);
}
inline const ::Range& ClearVoxels::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClearVoxels.z)
  return _internal_z();
}
inline void ClearVoxels::unsafe_arena_set_allocated_z(::Range* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClearVoxels.z)
}
inline ::Range* ClearVoxels::release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Range* released = _impl_.z_;
  _impl_.z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Range* ClearVoxels::unsafe_arena_release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClearVoxels.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Range* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::Range* ClearVoxels::_internal_mutable_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Range>(GetArena());
    _impl_.z_ = reinterpret_cast<::Range*>(p);
  }
  return _impl_.z_;
}
inline ::Range* ClearVoxels::mutable_z() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::Range* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:ClearVoxels.z)
  return _msg;
}
inline void ClearVoxels::set_allocated_z(::Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClearVoxels.z)
}

// -------------------------------------------------------------------

// ConfirmAction

// int64 actionId = 1;
inline void ConfirmAction::clear_actionid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = ::int64_t{0};
}
inline ::int64_t ConfirmAction::actionid() const {
  // @@protoc_insertion_point(field_get:ConfirmAction.actionId)
  return _internal_actionid();
}
inline void ConfirmAction::set_actionid(::int64_t value) {
  _internal_set_actionid(value);
  // @@protoc_insertion_point(field_set:ConfirmAction.actionId)
}
inline ::int64_t ConfirmAction::_internal_actionid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actionid_;
}
inline void ConfirmAction::_internal_set_actionid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = value;
}

// -------------------------------------------------------------------

// KeyReplayEntry

// string sym = 1;
inline void KeyReplayEntry::clear_sym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.ClearToEmpty();
}
inline const std::string& KeyReplayEntry::sym() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KeyReplayEntry.sym)
  return _internal_sym();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyReplayEntry::set_sym(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KeyReplayEntry.sym)
}
inline std::string* KeyReplayEntry::mutable_sym() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sym();
  // @@protoc_insertion_point(field_mutable:KeyReplayEntry.sym)
  return _s;
}
inline const std::string& KeyReplayEntry::_internal_sym() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sym_.Get();
}
inline void KeyReplayEntry::_internal_set_sym(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.Set(value, GetArena());
}
inline std::string* KeyReplayEntry::_internal_mutable_sym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sym_.Mutable( GetArena());
}
inline std::string* KeyReplayEntry::release_sym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:KeyReplayEntry.sym)
  return _impl_.sym_.Release();
}
inline void KeyReplayEntry::set_allocated_sym(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sym_.IsDefault()) {
          _impl_.sym_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KeyReplayEntry.sym)
}

// uint32 delay_ms = 2;
inline void KeyReplayEntry::clear_delay_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = 0u;
}
inline ::uint32_t KeyReplayEntry::delay_ms() const {
  // @@protoc_insertion_point(field_get:KeyReplayEntry.delay_ms)
  return _internal_delay_ms();
}
inline void KeyReplayEntry::set_delay_ms(::uint32_t value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:KeyReplayEntry.delay_ms)
}
inline ::uint32_t KeyReplayEntry::_internal_delay_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_ms_;
}
inline void KeyReplayEntry::_internal_set_delay_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = value;
}

// -------------------------------------------------------------------

// KeyReplay

// repeated .KeyReplayEntry entries = 1;
inline int KeyReplay::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int KeyReplay::entries_size() const {
  return _internal_entries_size();
}
inline void KeyReplay::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::KeyReplayEntry* KeyReplay::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:KeyReplay.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* KeyReplay::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:KeyReplay.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::KeyReplayEntry& KeyReplay::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KeyReplay.entries)
  return _internal_entries().Get(index);
}
inline ::KeyReplayEntry* KeyReplay::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::KeyReplayEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:KeyReplay.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>& KeyReplay::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:KeyReplay.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>&
KeyReplay::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>*
KeyReplay::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// PointerReplayEntry

// uint32 button = 1;
inline void PointerReplayEntry::clear_button() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.button_ = 0u;
}
inline ::uint32_t PointerReplayEntry::button() const {
  // @@protoc_insertion_point(field_get:PointerReplayEntry.button)
  return _internal_button();
}
inline void PointerReplayEntry::set_button(::uint32_t value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:PointerReplayEntry.button)
}
inline ::uint32_t PointerReplayEntry::_internal_button() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.button_;
}
inline void PointerReplayEntry::_internal_set_button(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.button_ = value;
}

// bool pressed = 2;
inline void PointerReplayEntry::clear_pressed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pressed_ = false;
}
inline bool PointerReplayEntry::pressed() const {
  // @@protoc_insertion_point(field_get:PointerReplayEntry.pressed)
  return _internal_pressed();
}
inline void PointerReplayEntry::set_pressed(bool value) {
  _internal_set_pressed(value);
  // @@protoc_insertion_point(field_set:PointerReplayEntry.pressed)
}
inline bool PointerReplayEntry::_internal_pressed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pressed_;
}
inline void PointerReplayEntry::_internal_set_pressed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pressed_ = value;
}

// uint32 delay_ms = 3;
inline void PointerReplayEntry::clear_delay_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = 0u;
}
inline ::uint32_t PointerReplayEntry::delay_ms() const {
  // @@protoc_insertion_point(field_get:PointerReplayEntry.delay_ms)
  return _internal_delay_ms();
}
inline void PointerReplayEntry::set_delay_ms(::uint32_t value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:PointerReplayEntry.delay_ms)
}
inline ::uint32_t PointerReplayEntry::_internal_delay_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_ms_;
}
inline void PointerReplayEntry::_internal_set_delay_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = value;
}

// -------------------------------------------------------------------

// PointerReplay

// repeated .PointerReplayEntry entries = 1;
inline int PointerReplay::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int PointerReplay::entries_size() const {
  return _internal_entries_size();
}
inline void PointerReplay::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::PointerReplayEntry* PointerReplay::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PointerReplay.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* PointerReplay::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:PointerReplay.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::PointerReplayEntry& PointerReplay::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PointerReplay.entries)
  return _internal_entries().Get(index);
}
inline ::PointerReplayEntry* PointerReplay::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::PointerReplayEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:PointerReplay.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>& PointerReplay::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PointerReplay.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>&
PointerReplay::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>*
PointerReplay::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// CreateEntity

// -------------------------------------------------------------------

// DeleteEntity

// -------------------------------------------------------------------

// ListEntities

// .ComponentType filter_type = 1;
inline void ListEntities::clear_filter_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_type_ = 0;
}
inline ::ComponentType ListEntities::filter_type() const {
  // @@protoc_insertion_point(field_get:ListEntities.filter_type)
  return _internal_filter_type();
}
inline void ListEntities::set_filter_type(::ComponentType value) {
  _internal_set_filter_type(value);
  // @@protoc_insertion_point(field_set:ListEntities.filter_type)
}
inline ::ComponentType ListEntities::_internal_filter_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ComponentType>(_impl_.filter_type_);
}
inline void ListEntities::_internal_set_filter_type(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_type_ = value;
}

// -------------------------------------------------------------------

// GetComponent

// .ComponentType component_type = 1;
inline void GetComponent::clear_component_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_type_ = 0;
}
inline ::ComponentType GetComponent::component_type() const {
  // @@protoc_insertion_point(field_get:GetComponent.component_type)
  return _internal_component_type();
}
inline void GetComponent::set_component_type(::ComponentType value) {
  _internal_set_component_type(value);
  // @@protoc_insertion_point(field_set:GetComponent.component_type)
}
inline ::ComponentType GetComponent::_internal_component_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ComponentType>(_impl_.component_type_);
}
inline void GetComponent::_internal_set_component_type(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_type_ = value;
}

// -------------------------------------------------------------------

// LoadURDF

// string urdf_path = 1;
inline void LoadURDF::clear_urdf_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urdf_path_.ClearToEmpty();
}
inline const std::string& LoadURDF::urdf_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LoadURDF.urdf_path)
  return _internal_urdf_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoadURDF::set_urdf_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urdf_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:LoadURDF.urdf_path)
}
inline std::string* LoadURDF::mutable_urdf_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_urdf_path();
  // @@protoc_insertion_point(field_mutable:LoadURDF.urdf_path)
  return _s;
}
inline const std::string& LoadURDF::_internal_urdf_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.urdf_path_.Get();
}
inline void LoadURDF::_internal_set_urdf_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urdf_path_.Set(value, GetArena());
}
inline std::string* LoadURDF::_internal_mutable_urdf_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.urdf_path_.Mutable( GetArena());
}
inline std::string* LoadURDF::release_urdf_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LoadURDF.urdf_path)
  return _impl_.urdf_path_.Release();
}
inline void LoadURDF::set_allocated_urdf_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urdf_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.urdf_path_.IsDefault()) {
          _impl_.urdf_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LoadURDF.urdf_path)
}

// .Vector initial_position = 2;
inline bool LoadURDF::has_initial_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.initial_position_ != nullptr);
  return value;
}
inline void LoadURDF::clear_initial_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.initial_position_ != nullptr) _impl_.initial_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Vector& LoadURDF::_internal_initial_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.initial_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& LoadURDF::initial_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LoadURDF.initial_position)
  return _internal_initial_position();
}
inline void LoadURDF::unsafe_arena_set_allocated_initial_position(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.initial_position_);
  }
  _impl_.initial_position_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LoadURDF.initial_position)
}
inline ::Vector* LoadURDF::release_initial_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* released = _impl_.initial_position_;
  _impl_.initial_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* LoadURDF::unsafe_arena_release_initial_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LoadURDF.initial_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* temp = _impl_.initial_position_;
  _impl_.initial_position_ = nullptr;
  return temp;
}
inline ::Vector* LoadURDF::_internal_mutable_initial_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.initial_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.initial_position_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.initial_position_;
}
inline ::Vector* LoadURDF::mutable_initial_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Vector* _msg = _internal_mutable_initial_position();
  // @@protoc_insertion_point(field_mutable:LoadURDF.initial_position)
  return _msg;
}
inline void LoadURDF::set_allocated_initial_position(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.initial_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.initial_position_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:LoadURDF.initial_position)
}

// -------------------------------------------------------------------

// EngineStatus

// uint32 total_entities = 1;
inline void EngineStatus::clear_total_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_entities_ = 0u;
}
inline ::uint32_t EngineStatus::total_entities() const {
  // @@protoc_insertion_point(field_get:EngineStatus.total_entities)
  return _internal_total_entities();
}
inline void EngineStatus::set_total_entities(::uint32_t value) {
  _internal_set_total_entities(value);
  // @@protoc_insertion_point(field_set:EngineStatus.total_entities)
}
inline ::uint32_t EngineStatus::_internal_total_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_entities_;
}
inline void EngineStatus::_internal_set_total_entities(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_entities_ = value;
}

// uint32 wayland_apps = 2;
inline void EngineStatus::clear_wayland_apps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_apps_ = 0u;
}
inline ::uint32_t EngineStatus::wayland_apps() const {
  // @@protoc_insertion_point(field_get:EngineStatus.wayland_apps)
  return _internal_wayland_apps();
}
inline void EngineStatus::set_wayland_apps(::uint32_t value) {
  _internal_set_wayland_apps(value);
  // @@protoc_insertion_point(field_set:EngineStatus.wayland_apps)
}
inline ::uint32_t EngineStatus::_internal_wayland_apps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wayland_apps_;
}
inline void EngineStatus::_internal_set_wayland_apps(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_apps_ = value;
}

// bool wayland_focus = 3;
inline void EngineStatus::clear_wayland_focus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_focus_ = false;
}
inline bool EngineStatus::wayland_focus() const {
  // @@protoc_insertion_point(field_get:EngineStatus.wayland_focus)
  return _internal_wayland_focus();
}
inline void EngineStatus::set_wayland_focus(bool value) {
  _internal_set_wayland_focus(value);
  // @@protoc_insertion_point(field_set:EngineStatus.wayland_focus)
}
inline bool EngineStatus::_internal_wayland_focus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wayland_focus_;
}
inline void EngineStatus::_internal_set_wayland_focus(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_focus_ = value;
}

// .Vector camera_position = 4;
inline bool EngineStatus::has_camera_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_position_ != nullptr);
  return value;
}
inline void EngineStatus::clear_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.camera_position_ != nullptr) _impl_.camera_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Vector& EngineStatus::_internal_camera_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.camera_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& EngineStatus::camera_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:EngineStatus.camera_position)
  return _internal_camera_position();
}
inline void EngineStatus::unsafe_arena_set_allocated_camera_position(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.camera_position_);
  }
  _impl_.camera_position_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EngineStatus.camera_position)
}
inline ::Vector* EngineStatus::release_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* released = _impl_.camera_position_;
  _impl_.camera_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* EngineStatus::unsafe_arena_release_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:EngineStatus.camera_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* temp = _impl_.camera_position_;
  _impl_.camera_position_ = nullptr;
  return temp;
}
inline ::Vector* EngineStatus::_internal_mutable_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.camera_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.camera_position_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.camera_position_;
}
inline ::Vector* EngineStatus::mutable_camera_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Vector* _msg = _internal_mutable_camera_position();
  // @@protoc_insertion_point(field_mutable:EngineStatus.camera_position)
  return _msg;
}
inline void EngineStatus::set_allocated_camera_position(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.camera_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.camera_position_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:EngineStatus.camera_position)
}

// -------------------------------------------------------------------

// Move

// float xDelta = 1;
inline void Move::clear_xdelta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xdelta_ = 0;
}
inline float Move::xdelta() const {
  // @@protoc_insertion_point(field_get:Move.xDelta)
  return _internal_xdelta();
}
inline void Move::set_xdelta(float value) {
  _internal_set_xdelta(value);
  // @@protoc_insertion_point(field_set:Move.xDelta)
}
inline float Move::_internal_xdelta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.xdelta_;
}
inline void Move::_internal_set_xdelta(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xdelta_ = value;
}

// float yDelta = 2;
inline void Move::clear_ydelta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ydelta_ = 0;
}
inline float Move::ydelta() const {
  // @@protoc_insertion_point(field_get:Move.yDelta)
  return _internal_ydelta();
}
inline void Move::set_ydelta(float value) {
  _internal_set_ydelta(value);
  // @@protoc_insertion_point(field_set:Move.yDelta)
}
inline float Move::_internal_ydelta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ydelta_;
}
inline void Move::_internal_set_ydelta(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ydelta_ = value;
}

// float zDelta = 3;
inline void Move::clear_zdelta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zdelta_ = 0;
}
inline float Move::zdelta() const {
  // @@protoc_insertion_point(field_get:Move.zDelta)
  return _internal_zdelta();
}
inline void Move::set_zdelta(float value) {
  _internal_set_zdelta(value);
  // @@protoc_insertion_point(field_set:Move.zDelta)
}
inline float Move::_internal_zdelta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.zdelta_;
}
inline void Move::_internal_set_zdelta(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zdelta_ = value;
}

// float unitsPerSecond = 4;
inline void Move::clear_unitspersecond() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = 0;
}
inline float Move::unitspersecond() const {
  // @@protoc_insertion_point(field_get:Move.unitsPerSecond)
  return _internal_unitspersecond();
}
inline void Move::set_unitspersecond(float value) {
  _internal_set_unitspersecond(value);
  // @@protoc_insertion_point(field_set:Move.unitsPerSecond)
}
inline float Move::_internal_unitspersecond() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unitspersecond_;
}
inline void Move::_internal_set_unitspersecond(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = value;
}

// -------------------------------------------------------------------

// TurnKey

// bool on = 2;
inline void TurnKey::clear_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_ = false;
}
inline bool TurnKey::on() const {
  // @@protoc_insertion_point(field_get:TurnKey.on)
  return _internal_on();
}
inline void TurnKey::set_on(bool value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:TurnKey.on)
}
inline bool TurnKey::_internal_on() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_;
}
inline void TurnKey::_internal_set_on(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_ = value;
}

// -------------------------------------------------------------------

// ApiRequest

// int64 entityId = 1;
inline void ApiRequest::clear_entityid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = ::int64_t{0};
}
inline ::int64_t ApiRequest::entityid() const {
  // @@protoc_insertion_point(field_get:ApiRequest.entityId)
  return _internal_entityid();
}
inline void ApiRequest::set_entityid(::int64_t value) {
  _internal_set_entityid(value);
  // @@protoc_insertion_point(field_set:ApiRequest.entityId)
}
inline ::int64_t ApiRequest::_internal_entityid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entityid_;
}
inline void ApiRequest::_internal_set_entityid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = value;
}

// .MessageType type = 2;
inline void ApiRequest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::MessageType ApiRequest::type() const {
  // @@protoc_insertion_point(field_get:ApiRequest.type)
  return _internal_type();
}
inline void ApiRequest::set_type(::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ApiRequest.type)
}
inline ::MessageType ApiRequest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::MessageType>(_impl_.type_);
}
inline void ApiRequest::_internal_set_type(::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .Move move = 3;
inline bool ApiRequest::has_move() const {
  return payload_case() == kMove;
}
inline bool ApiRequest::_internal_has_move() const {
  return payload_case() == kMove;
}
inline void ApiRequest::set_has_move() {
  _impl_._oneof_case_[0] = kMove;
}
inline void ApiRequest::clear_move() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kMove) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.move_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.move_);
    }
    clear_has_payload();
  }
}
inline ::Move* ApiRequest::release_move() {
  // @@protoc_insertion_point(field_release:ApiRequest.move)
  if (payload_case() == kMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Move& ApiRequest::_internal_move() const {
  return payload_case() == kMove ? *_impl_.payload_.move_ : reinterpret_cast<::Move&>(::_Move_default_instance_);
}
inline const ::Move& ApiRequest::move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.move)
  return _internal_move();
}
inline ::Move* ApiRequest::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.move)
  if (payload_case() == kMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_;
    _impl_.payload_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_move(::Move* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_move();
    _impl_.payload_.move_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.move)
}
inline ::Move* ApiRequest::_internal_mutable_move() {
  if (payload_case() != kMove) {
    clear_payload();
    set_has_move();
    _impl_.payload_.move_ =
        ::google::protobuf::Message::DefaultConstruct<::Move>(GetArena());
  }
  return _impl_.payload_.move_;
}
inline ::Move* ApiRequest::mutable_move() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Move* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:ApiRequest.move)
  return _msg;
}

// .TurnKey turnKey = 4;
inline bool ApiRequest::has_turnkey() const {
  return payload_case() == kTurnKey;
}
inline bool ApiRequest::_internal_has_turnkey() const {
  return payload_case() == kTurnKey;
}
inline void ApiRequest::set_has_turnkey() {
  _impl_._oneof_case_[0] = kTurnKey;
}
inline void ApiRequest::clear_turnkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kTurnKey) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.turnkey_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.turnkey_);
    }
    clear_has_payload();
  }
}
inline ::TurnKey* ApiRequest::release_turnkey() {
  // @@protoc_insertion_point(field_release:ApiRequest.turnKey)
  if (payload_case() == kTurnKey) {
    clear_has_payload();
    auto* temp = _impl_.payload_.turnkey_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.turnkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TurnKey& ApiRequest::_internal_turnkey() const {
  return payload_case() == kTurnKey ? *_impl_.payload_.turnkey_ : reinterpret_cast<::TurnKey&>(::_TurnKey_default_instance_);
}
inline const ::TurnKey& ApiRequest::turnkey() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.turnKey)
  return _internal_turnkey();
}
inline ::TurnKey* ApiRequest::unsafe_arena_release_turnkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.turnKey)
  if (payload_case() == kTurnKey) {
    clear_has_payload();
    auto* temp = _impl_.payload_.turnkey_;
    _impl_.payload_.turnkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_turnkey(::TurnKey* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_turnkey();
    _impl_.payload_.turnkey_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.turnKey)
}
inline ::TurnKey* ApiRequest::_internal_mutable_turnkey() {
  if (payload_case() != kTurnKey) {
    clear_payload();
    set_has_turnkey();
    _impl_.payload_.turnkey_ =
        ::google::protobuf::Message::DefaultConstruct<::TurnKey>(GetArena());
  }
  return _impl_.payload_.turnkey_;
}
inline ::TurnKey* ApiRequest::mutable_turnkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TurnKey* _msg = _internal_mutable_turnkey();
  // @@protoc_insertion_point(field_mutable:ApiRequest.turnKey)
  return _msg;
}

// .PlayerMove playerMove = 5;
inline bool ApiRequest::has_playermove() const {
  return payload_case() == kPlayerMove;
}
inline bool ApiRequest::_internal_has_playermove() const {
  return payload_case() == kPlayerMove;
}
inline void ApiRequest::set_has_playermove() {
  _impl_._oneof_case_[0] = kPlayerMove;
}
inline void ApiRequest::clear_playermove() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPlayerMove) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.playermove_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.playermove_);
    }
    clear_has_payload();
  }
}
inline ::PlayerMove* ApiRequest::release_playermove() {
  // @@protoc_insertion_point(field_release:ApiRequest.playerMove)
  if (payload_case() == kPlayerMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.playermove_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.playermove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PlayerMove& ApiRequest::_internal_playermove() const {
  return payload_case() == kPlayerMove ? *_impl_.payload_.playermove_ : reinterpret_cast<::PlayerMove&>(::_PlayerMove_default_instance_);
}
inline const ::PlayerMove& ApiRequest::playermove() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.playerMove)
  return _internal_playermove();
}
inline ::PlayerMove* ApiRequest::unsafe_arena_release_playermove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.playerMove)
  if (payload_case() == kPlayerMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.playermove_;
    _impl_.payload_.playermove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_playermove(::PlayerMove* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_playermove();
    _impl_.payload_.playermove_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.playerMove)
}
inline ::PlayerMove* ApiRequest::_internal_mutable_playermove() {
  if (payload_case() != kPlayerMove) {
    clear_payload();
    set_has_playermove();
    _impl_.payload_.playermove_ =
        ::google::protobuf::Message::DefaultConstruct<::PlayerMove>(GetArena());
  }
  return _impl_.payload_.playermove_;
}
inline ::PlayerMove* ApiRequest::mutable_playermove() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PlayerMove* _msg = _internal_mutable_playermove();
  // @@protoc_insertion_point(field_mutable:ApiRequest.playerMove)
  return _msg;
}

// .NoPayload noPayload = 6;
inline bool ApiRequest::has_nopayload() const {
  return payload_case() == kNoPayload;
}
inline bool ApiRequest::_internal_has_nopayload() const {
  return payload_case() == kNoPayload;
}
inline void ApiRequest::set_has_nopayload() {
  _impl_._oneof_case_[0] = kNoPayload;
}
inline void ApiRequest::clear_nopayload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kNoPayload) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.nopayload_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.nopayload_);
    }
    clear_has_payload();
  }
}
inline ::NoPayload* ApiRequest::release_nopayload() {
  // @@protoc_insertion_point(field_release:ApiRequest.noPayload)
  if (payload_case() == kNoPayload) {
    clear_has_payload();
    auto* temp = _impl_.payload_.nopayload_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nopayload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::NoPayload& ApiRequest::_internal_nopayload() const {
  return payload_case() == kNoPayload ? *_impl_.payload_.nopayload_ : reinterpret_cast<::NoPayload&>(::_NoPayload_default_instance_);
}
inline const ::NoPayload& ApiRequest::nopayload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.noPayload)
  return _internal_nopayload();
}
inline ::NoPayload* ApiRequest::unsafe_arena_release_nopayload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.noPayload)
  if (payload_case() == kNoPayload) {
    clear_has_payload();
    auto* temp = _impl_.payload_.nopayload_;
    _impl_.payload_.nopayload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_nopayload(::NoPayload* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_nopayload();
    _impl_.payload_.nopayload_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.noPayload)
}
inline ::NoPayload* ApiRequest::_internal_mutable_nopayload() {
  if (payload_case() != kNoPayload) {
    clear_payload();
    set_has_nopayload();
    _impl_.payload_.nopayload_ =
        ::google::protobuf::Message::DefaultConstruct<::NoPayload>(GetArena());
  }
  return _impl_.payload_.nopayload_;
}
inline ::NoPayload* ApiRequest::mutable_nopayload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::NoPayload* _msg = _internal_mutable_nopayload();
  // @@protoc_insertion_point(field_mutable:ApiRequest.noPayload)
  return _msg;
}

// .AddVoxels addVoxels = 7;
inline bool ApiRequest::has_addvoxels() const {
  return payload_case() == kAddVoxels;
}
inline bool ApiRequest::_internal_has_addvoxels() const {
  return payload_case() == kAddVoxels;
}
inline void ApiRequest::set_has_addvoxels() {
  _impl_._oneof_case_[0] = kAddVoxels;
}
inline void ApiRequest::clear_addvoxels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kAddVoxels) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.addvoxels_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.addvoxels_);
    }
    clear_has_payload();
  }
}
inline ::AddVoxels* ApiRequest::release_addvoxels() {
  // @@protoc_insertion_point(field_release:ApiRequest.addVoxels)
  if (payload_case() == kAddVoxels) {
    clear_has_payload();
    auto* temp = _impl_.payload_.addvoxels_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.addvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AddVoxels& ApiRequest::_internal_addvoxels() const {
  return payload_case() == kAddVoxels ? *_impl_.payload_.addvoxels_ : reinterpret_cast<::AddVoxels&>(::_AddVoxels_default_instance_);
}
inline const ::AddVoxels& ApiRequest::addvoxels() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.addVoxels)
  return _internal_addvoxels();
}
inline ::AddVoxels* ApiRequest::unsafe_arena_release_addvoxels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.addVoxels)
  if (payload_case() == kAddVoxels) {
    clear_has_payload();
    auto* temp = _impl_.payload_.addvoxels_;
    _impl_.payload_.addvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_addvoxels(::AddVoxels* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_addvoxels();
    _impl_.payload_.addvoxels_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.addVoxels)
}
inline ::AddVoxels* ApiRequest::_internal_mutable_addvoxels() {
  if (payload_case() != kAddVoxels) {
    clear_payload();
    set_has_addvoxels();
    _impl_.payload_.addvoxels_ =
        ::google::protobuf::Message::DefaultConstruct<::AddVoxels>(GetArena());
  }
  return _impl_.payload_.addvoxels_;
}
inline ::AddVoxels* ApiRequest::mutable_addvoxels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AddVoxels* _msg = _internal_mutable_addvoxels();
  // @@protoc_insertion_point(field_mutable:ApiRequest.addVoxels)
  return _msg;
}

// .ClearVoxels clearVoxels = 8;
inline bool ApiRequest::has_clearvoxels() const {
  return payload_case() == kClearVoxels;
}
inline bool ApiRequest::_internal_has_clearvoxels() const {
  return payload_case() == kClearVoxels;
}
inline void ApiRequest::set_has_clearvoxels() {
  _impl_._oneof_case_[0] = kClearVoxels;
}
inline void ApiRequest::clear_clearvoxels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kClearVoxels) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.clearvoxels_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.clearvoxels_);
    }
    clear_has_payload();
  }
}
inline ::ClearVoxels* ApiRequest::release_clearvoxels() {
  // @@protoc_insertion_point(field_release:ApiRequest.clearVoxels)
  if (payload_case() == kClearVoxels) {
    clear_has_payload();
    auto* temp = _impl_.payload_.clearvoxels_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.clearvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClearVoxels& ApiRequest::_internal_clearvoxels() const {
  return payload_case() == kClearVoxels ? *_impl_.payload_.clearvoxels_ : reinterpret_cast<::ClearVoxels&>(::_ClearVoxels_default_instance_);
}
inline const ::ClearVoxels& ApiRequest::clearvoxels() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.clearVoxels)
  return _internal_clearvoxels();
}
inline ::ClearVoxels* ApiRequest::unsafe_arena_release_clearvoxels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.clearVoxels)
  if (payload_case() == kClearVoxels) {
    clear_has_payload();
    auto* temp = _impl_.payload_.clearvoxels_;
    _impl_.payload_.clearvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_clearvoxels(::ClearVoxels* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_clearvoxels();
    _impl_.payload_.clearvoxels_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.clearVoxels)
}
inline ::ClearVoxels* ApiRequest::_internal_mutable_clearvoxels() {
  if (payload_case() != kClearVoxels) {
    clear_payload();
    set_has_clearvoxels();
    _impl_.payload_.clearvoxels_ =
        ::google::protobuf::Message::DefaultConstruct<::ClearVoxels>(GetArena());
  }
  return _impl_.payload_.clearvoxels_;
}
inline ::ClearVoxels* ApiRequest::mutable_clearvoxels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ClearVoxels* _msg = _internal_mutable_clearvoxels();
  // @@protoc_insertion_point(field_mutable:ApiRequest.clearVoxels)
  return _msg;
}

// .ConfirmAction confirmAction = 9;
inline bool ApiRequest::has_confirmaction() const {
  return payload_case() == kConfirmAction;
}
inline bool ApiRequest::_internal_has_confirmaction() const {
  return payload_case() == kConfirmAction;
}
inline void ApiRequest::set_has_confirmaction() {
  _impl_._oneof_case_[0] = kConfirmAction;
}
inline void ApiRequest::clear_confirmaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kConfirmAction) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.confirmaction_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.confirmaction_);
    }
    clear_has_payload();
  }
}
inline ::ConfirmAction* ApiRequest::release_confirmaction() {
  // @@protoc_insertion_point(field_release:ApiRequest.confirmAction)
  if (payload_case() == kConfirmAction) {
    clear_has_payload();
    auto* temp = _impl_.payload_.confirmaction_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.confirmaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ConfirmAction& ApiRequest::_internal_confirmaction() const {
  return payload_case() == kConfirmAction ? *_impl_.payload_.confirmaction_ : reinterpret_cast<::ConfirmAction&>(::_ConfirmAction_default_instance_);
}
inline const ::ConfirmAction& ApiRequest::confirmaction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.confirmAction)
  return _internal_confirmaction();
}
inline ::ConfirmAction* ApiRequest::unsafe_arena_release_confirmaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.confirmAction)
  if (payload_case() == kConfirmAction) {
    clear_has_payload();
    auto* temp = _impl_.payload_.confirmaction_;
    _impl_.payload_.confirmaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_confirmaction(::ConfirmAction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_confirmaction();
    _impl_.payload_.confirmaction_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.confirmAction)
}
inline ::ConfirmAction* ApiRequest::_internal_mutable_confirmaction() {
  if (payload_case() != kConfirmAction) {
    clear_payload();
    set_has_confirmaction();
    _impl_.payload_.confirmaction_ =
        ::google::protobuf::Message::DefaultConstruct<::ConfirmAction>(GetArena());
  }
  return _impl_.payload_.confirmaction_;
}
inline ::ConfirmAction* ApiRequest::mutable_confirmaction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ConfirmAction* _msg = _internal_mutable_confirmaction();
  // @@protoc_insertion_point(field_mutable:ApiRequest.confirmAction)
  return _msg;
}

// .KeyReplay keyReplay = 10;
inline bool ApiRequest::has_keyreplay() const {
  return payload_case() == kKeyReplay;
}
inline bool ApiRequest::_internal_has_keyreplay() const {
  return payload_case() == kKeyReplay;
}
inline void ApiRequest::set_has_keyreplay() {
  _impl_._oneof_case_[0] = kKeyReplay;
}
inline void ApiRequest::clear_keyreplay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kKeyReplay) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.keyreplay_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.keyreplay_);
    }
    clear_has_payload();
  }
}
inline ::KeyReplay* ApiRequest::release_keyreplay() {
  // @@protoc_insertion_point(field_release:ApiRequest.keyReplay)
  if (payload_case() == kKeyReplay) {
    clear_has_payload();
    auto* temp = _impl_.payload_.keyreplay_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.keyreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KeyReplay& ApiRequest::_internal_keyreplay() const {
  return payload_case() == kKeyReplay ? *_impl_.payload_.keyreplay_ : reinterpret_cast<::KeyReplay&>(::_KeyReplay_default_instance_);
}
inline const ::KeyReplay& ApiRequest::keyreplay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.keyReplay)
  return _internal_keyreplay();
}
inline ::KeyReplay* ApiRequest::unsafe_arena_release_keyreplay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.keyReplay)
  if (payload_case() == kKeyReplay) {
    clear_has_payload();
    auto* temp = _impl_.payload_.keyreplay_;
    _impl_.payload_.keyreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_keyreplay(::KeyReplay* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_keyreplay();
    _impl_.payload_.keyreplay_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.keyReplay)
}
inline ::KeyReplay* ApiRequest::_internal_mutable_keyreplay() {
  if (payload_case() != kKeyReplay) {
    clear_payload();
    set_has_keyreplay();
    _impl_.payload_.keyreplay_ =
        ::google::protobuf::Message::DefaultConstruct<::KeyReplay>(GetArena());
  }
  return _impl_.payload_.keyreplay_;
}
inline ::KeyReplay* ApiRequest::mutable_keyreplay() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KeyReplay* _msg = _internal_mutable_keyreplay();
  // @@protoc_insertion_point(field_mutable:ApiRequest.keyReplay)
  return _msg;
}

// .PointerReplay pointerReplay = 11;
inline bool ApiRequest::has_pointerreplay() const {
  return payload_case() == kPointerReplay;
}
inline bool ApiRequest::_internal_has_pointerreplay() const {
  return payload_case() == kPointerReplay;
}
inline void ApiRequest::set_has_pointerreplay() {
  _impl_._oneof_case_[0] = kPointerReplay;
}
inline void ApiRequest::clear_pointerreplay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPointerReplay) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.pointerreplay_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.pointerreplay_);
    }
    clear_has_payload();
  }
}
inline ::PointerReplay* ApiRequest::release_pointerreplay() {
  // @@protoc_insertion_point(field_release:ApiRequest.pointerReplay)
  if (payload_case() == kPointerReplay) {
    clear_has_payload();
    auto* temp = _impl_.payload_.pointerreplay_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.pointerreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PointerReplay& ApiRequest::_internal_pointerreplay() const {
  return payload_case() == kPointerReplay ? *_impl_.payload_.pointerreplay_ : reinterpret_cast<::PointerReplay&>(::_PointerReplay_default_instance_);
}
inline const ::PointerReplay& ApiRequest::pointerreplay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.pointerReplay)
  return _internal_pointerreplay();
}
inline ::PointerReplay* ApiRequest::unsafe_arena_release_pointerreplay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.pointerReplay)
  if (payload_case() == kPointerReplay) {
    clear_has_payload();
    auto* temp = _impl_.payload_.pointerreplay_;
    _impl_.payload_.pointerreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_pointerreplay(::PointerReplay* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_pointerreplay();
    _impl_.payload_.pointerreplay_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.pointerReplay)
}
inline ::PointerReplay* ApiRequest::_internal_mutable_pointerreplay() {
  if (payload_case() != kPointerReplay) {
    clear_payload();
    set_has_pointerreplay();
    _impl_.payload_.pointerreplay_ =
        ::google::protobuf::Message::DefaultConstruct<::PointerReplay>(GetArena());
  }
  return _impl_.payload_.pointerreplay_;
}
inline ::PointerReplay* ApiRequest::mutable_pointerreplay() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PointerReplay* _msg = _internal_mutable_pointerreplay();
  // @@protoc_insertion_point(field_mutable:ApiRequest.pointerReplay)
  return _msg;
}

// .AddComponent addComponent = 12;
inline bool ApiRequest::has_addcomponent() const {
  return payload_case() == kAddComponent;
}
inline bool ApiRequest::_internal_has_addcomponent() const {
  return payload_case() == kAddComponent;
}
inline void ApiRequest::set_has_addcomponent() {
  _impl_._oneof_case_[0] = kAddComponent;
}
inline void ApiRequest::clear_addcomponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kAddComponent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.addcomponent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.addcomponent_);
    }
    clear_has_payload();
  }
}
inline ::AddComponent* ApiRequest::release_addcomponent() {
  // @@protoc_insertion_point(field_release:ApiRequest.addComponent)
  if (payload_case() == kAddComponent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.addcomponent_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.addcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AddComponent& ApiRequest::_internal_addcomponent() const {
  return payload_case() == kAddComponent ? *_impl_.payload_.addcomponent_ : reinterpret_cast<::AddComponent&>(::_AddComponent_default_instance_);
}
inline const ::AddComponent& ApiRequest::addcomponent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.addComponent)
  return _internal_addcomponent();
}
inline ::AddComponent* ApiRequest::unsafe_arena_release_addcomponent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.addComponent)
  if (payload_case() == kAddComponent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.addcomponent_;
    _impl_.payload_.addcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_addcomponent(::AddComponent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_addcomponent();
    _impl_.payload_.addcomponent_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.addComponent)
}
inline ::AddComponent* ApiRequest::_internal_mutable_addcomponent() {
  if (payload_case() != kAddComponent) {
    clear_payload();
    set_has_addcomponent();
    _impl_.payload_.addcomponent_ =
        ::google::protobuf::Message::DefaultConstruct<::AddComponent>(GetArena());
  }
  return _impl_.payload_.addcomponent_;
}
inline ::AddComponent* ApiRequest::mutable_addcomponent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AddComponent* _msg = _internal_mutable_addcomponent();
  // @@protoc_insertion_point(field_mutable:ApiRequest.addComponent)
  return _msg;
}

// .DeleteComponent deleteComponent = 13;
inline bool ApiRequest::has_deletecomponent() const {
  return payload_case() == kDeleteComponent;
}
inline bool ApiRequest::_internal_has_deletecomponent() const {
  return payload_case() == kDeleteComponent;
}
inline void ApiRequest::set_has_deletecomponent() {
  _impl_._oneof_case_[0] = kDeleteComponent;
}
inline void ApiRequest::clear_deletecomponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kDeleteComponent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.deletecomponent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.deletecomponent_);
    }
    clear_has_payload();
  }
}
inline ::DeleteComponent* ApiRequest::release_deletecomponent() {
  // @@protoc_insertion_point(field_release:ApiRequest.deleteComponent)
  if (payload_case() == kDeleteComponent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.deletecomponent_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.deletecomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DeleteComponent& ApiRequest::_internal_deletecomponent() const {
  return payload_case() == kDeleteComponent ? *_impl_.payload_.deletecomponent_ : reinterpret_cast<::DeleteComponent&>(::_DeleteComponent_default_instance_);
}
inline const ::DeleteComponent& ApiRequest::deletecomponent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.deleteComponent)
  return _internal_deletecomponent();
}
inline ::DeleteComponent* ApiRequest::unsafe_arena_release_deletecomponent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.deleteComponent)
  if (payload_case() == kDeleteComponent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.deletecomponent_;
    _impl_.payload_.deletecomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_deletecomponent(::DeleteComponent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_deletecomponent();
    _impl_.payload_.deletecomponent_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.deleteComponent)
}
inline ::DeleteComponent* ApiRequest::_internal_mutable_deletecomponent() {
  if (payload_case() != kDeleteComponent) {
    clear_payload();
    set_has_deletecomponent();
    _impl_.payload_.deletecomponent_ =
        ::google::protobuf::Message::DefaultConstruct<::DeleteComponent>(GetArena());
  }
  return _impl_.payload_.deletecomponent_;
}
inline ::DeleteComponent* ApiRequest::mutable_deletecomponent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DeleteComponent* _msg = _internal_mutable_deletecomponent();
  // @@protoc_insertion_point(field_mutable:ApiRequest.deleteComponent)
  return _msg;
}

// .EditComponent editComponent = 14;
inline bool ApiRequest::has_editcomponent() const {
  return payload_case() == kEditComponent;
}
inline bool ApiRequest::_internal_has_editcomponent() const {
  return payload_case() == kEditComponent;
}
inline void ApiRequest::set_has_editcomponent() {
  _impl_._oneof_case_[0] = kEditComponent;
}
inline void ApiRequest::clear_editcomponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kEditComponent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.editcomponent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.editcomponent_);
    }
    clear_has_payload();
  }
}
inline ::EditComponent* ApiRequest::release_editcomponent() {
  // @@protoc_insertion_point(field_release:ApiRequest.editComponent)
  if (payload_case() == kEditComponent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.editcomponent_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.editcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::EditComponent& ApiRequest::_internal_editcomponent() const {
  return payload_case() == kEditComponent ? *_impl_.payload_.editcomponent_ : reinterpret_cast<::EditComponent&>(::_EditComponent_default_instance_);
}
inline const ::EditComponent& ApiRequest::editcomponent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.editComponent)
  return _internal_editcomponent();
}
inline ::EditComponent* ApiRequest::unsafe_arena_release_editcomponent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.editComponent)
  if (payload_case() == kEditComponent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.editcomponent_;
    _impl_.payload_.editcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_editcomponent(::EditComponent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_editcomponent();
    _impl_.payload_.editcomponent_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.editComponent)
}
inline ::EditComponent* ApiRequest::_internal_mutable_editcomponent() {
  if (payload_case() != kEditComponent) {
    clear_payload();
    set_has_editcomponent();
    _impl_.payload_.editcomponent_ =
        ::google::protobuf::Message::DefaultConstruct<::EditComponent>(GetArena());
  }
  return _impl_.payload_.editcomponent_;
}
inline ::EditComponent* ApiRequest::mutable_editcomponent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::EditComponent* _msg = _internal_mutable_editcomponent();
  // @@protoc_insertion_point(field_mutable:ApiRequest.editComponent)
  return _msg;
}

// .CreateEntity createEntity = 15;
inline bool ApiRequest::has_createentity() const {
  return payload_case() == kCreateEntity;
}
inline bool ApiRequest::_internal_has_createentity() const {
  return payload_case() == kCreateEntity;
}
inline void ApiRequest::set_has_createentity() {
  _impl_._oneof_case_[0] = kCreateEntity;
}
inline void ApiRequest::clear_createentity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kCreateEntity) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.createentity_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.createentity_);
    }
    clear_has_payload();
  }
}
inline ::CreateEntity* ApiRequest::release_createentity() {
  // @@protoc_insertion_point(field_release:ApiRequest.createEntity)
  if (payload_case() == kCreateEntity) {
    clear_has_payload();
    auto* temp = _impl_.payload_.createentity_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.createentity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CreateEntity& ApiRequest::_internal_createentity() const {
  return payload_case() == kCreateEntity ? *_impl_.payload_.createentity_ : reinterpret_cast<::CreateEntity&>(::_CreateEntity_default_instance_);
}
inline const ::CreateEntity& ApiRequest::createentity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.createEntity)
  return _internal_createentity();
}
inline ::CreateEntity* ApiRequest::unsafe_arena_release_createentity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.createEntity)
  if (payload_case() == kCreateEntity) {
    clear_has_payload();
    auto* temp = _impl_.payload_.createentity_;
    _impl_.payload_.createentity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_createentity(::CreateEntity* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_createentity();
    _impl_.payload_.createentity_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.createEntity)
}
inline ::CreateEntity* ApiRequest::_internal_mutable_createentity() {
  if (payload_case() != kCreateEntity) {
    clear_payload();
    set_has_createentity();
    _impl_.payload_.createentity_ =
        ::google::protobuf::Message::DefaultConstruct<::CreateEntity>(GetArena());
  }
  return _impl_.payload_.createentity_;
}
inline ::CreateEntity* ApiRequest::mutable_createentity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::CreateEntity* _msg = _internal_mutable_createentity();
  // @@protoc_insertion_point(field_mutable:ApiRequest.createEntity)
  return _msg;
}

// .DeleteEntity deleteEntity = 16;
inline bool ApiRequest::has_deleteentity() const {
  return payload_case() == kDeleteEntity;
}
inline bool ApiRequest::_internal_has_deleteentity() const {
  return payload_case() == kDeleteEntity;
}
inline void ApiRequest::set_has_deleteentity() {
  _impl_._oneof_case_[0] = kDeleteEntity;
}
inline void ApiRequest::clear_deleteentity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kDeleteEntity) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.deleteentity_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.deleteentity_);
    }
    clear_has_payload();
  }
}
inline ::DeleteEntity* ApiRequest::release_deleteentity() {
  // @@protoc_insertion_point(field_release:ApiRequest.deleteEntity)
  if (payload_case() == kDeleteEntity) {
    clear_has_payload();
    auto* temp = _impl_.payload_.deleteentity_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.deleteentity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DeleteEntity& ApiRequest::_internal_deleteentity() const {
  return payload_case() == kDeleteEntity ? *_impl_.payload_.deleteentity_ : reinterpret_cast<::DeleteEntity&>(::_DeleteEntity_default_instance_);
}
inline const ::DeleteEntity& ApiRequest::deleteentity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.deleteEntity)
  return _internal_deleteentity();
}
inline ::DeleteEntity* ApiRequest::unsafe_arena_release_deleteentity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.deleteEntity)
  if (payload_case() == kDeleteEntity) {
    clear_has_payload();
    auto* temp = _impl_.payload_.deleteentity_;
    _impl_.payload_.deleteentity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_deleteentity(::DeleteEntity* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_deleteentity();
    _impl_.payload_.deleteentity_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.deleteEntity)
}
inline ::DeleteEntity* ApiRequest::_internal_mutable_deleteentity() {
  if (payload_case() != kDeleteEntity) {
    clear_payload();
    set_has_deleteentity();
    _impl_.payload_.deleteentity_ =
        ::google::protobuf::Message::DefaultConstruct<::DeleteEntity>(GetArena());
  }
  return _impl_.payload_.deleteentity_;
}
inline ::DeleteEntity* ApiRequest::mutable_deleteentity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DeleteEntity* _msg = _internal_mutable_deleteentity();
  // @@protoc_insertion_point(field_mutable:ApiRequest.deleteEntity)
  return _msg;
}

// .ListEntities listEntities = 17;
inline bool ApiRequest::has_listentities() const {
  return payload_case() == kListEntities;
}
inline bool ApiRequest::_internal_has_listentities() const {
  return payload_case() == kListEntities;
}
inline void ApiRequest::set_has_listentities() {
  _impl_._oneof_case_[0] = kListEntities;
}
inline void ApiRequest::clear_listentities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kListEntities) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.listentities_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.listentities_);
    }
    clear_has_payload();
  }
}
inline ::ListEntities* ApiRequest::release_listentities() {
  // @@protoc_insertion_point(field_release:ApiRequest.listEntities)
  if (payload_case() == kListEntities) {
    clear_has_payload();
    auto* temp = _impl_.payload_.listentities_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.listentities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ListEntities& ApiRequest::_internal_listentities() const {
  return payload_case() == kListEntities ? *_impl_.payload_.listentities_ : reinterpret_cast<::ListEntities&>(::_ListEntities_default_instance_);
}
inline const ::ListEntities& ApiRequest::listentities() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.listEntities)
  return _internal_listentities();
}
inline ::ListEntities* ApiRequest::unsafe_arena_release_listentities() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.listEntities)
  if (payload_case() == kListEntities) {
    clear_has_payload();
    auto* temp = _impl_.payload_.listentities_;
    _impl_.payload_.listentities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_listentities(::ListEntities* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_listentities();
    _impl_.payload_.listentities_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.listEntities)
}
inline ::ListEntities* ApiRequest::_internal_mutable_listentities() {
  if (payload_case() != kListEntities) {
    clear_payload();
    set_has_listentities();
    _impl_.payload_.listentities_ =
        ::google::protobuf::Message::DefaultConstruct<::ListEntities>(GetArena());
  }
  return _impl_.payload_.listentities_;
}
inline ::ListEntities* ApiRequest::mutable_listentities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ListEntities* _msg = _internal_mutable_listentities();
  // @@protoc_insertion_point(field_mutable:ApiRequest.listEntities)
  return _msg;
}

// .GetComponent getComponent = 18;
inline bool ApiRequest::has_getcomponent() const {
  return payload_case() == kGetComponent;
}
inline bool ApiRequest::_internal_has_getcomponent() const {
  return payload_case() == kGetComponent;
}
inline void ApiRequest::set_has_getcomponent() {
  _impl_._oneof_case_[0] = kGetComponent;
}
inline void ApiRequest::clear_getcomponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGetComponent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.getcomponent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.getcomponent_);
    }
    clear_has_payload();
  }
}
inline ::GetComponent* ApiRequest::release_getcomponent() {
  // @@protoc_insertion_point(field_release:ApiRequest.getComponent)
  if (payload_case() == kGetComponent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.getcomponent_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.getcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GetComponent& ApiRequest::_internal_getcomponent() const {
  return payload_case() == kGetComponent ? *_impl_.payload_.getcomponent_ : reinterpret_cast<::GetComponent&>(::_GetComponent_default_instance_);
}
inline const ::GetComponent& ApiRequest::getcomponent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.getComponent)
  return _internal_getcomponent();
}
inline ::GetComponent* ApiRequest::unsafe_arena_release_getcomponent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.getComponent)
  if (payload_case() == kGetComponent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.getcomponent_;
    _impl_.payload_.getcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_getcomponent(::GetComponent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_getcomponent();
    _impl_.payload_.getcomponent_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.getComponent)
}
inline ::GetComponent* ApiRequest::_internal_mutable_getcomponent() {
  if (payload_case() != kGetComponent) {
    clear_payload();
    set_has_getcomponent();
    _impl_.payload_.getcomponent_ =
        ::google::protobuf::Message::DefaultConstruct<::GetComponent>(GetArena());
  }
  return _impl_.payload_.getcomponent_;
}
inline ::GetComponent* ApiRequest::mutable_getcomponent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GetComponent* _msg = _internal_mutable_getcomponent();
  // @@protoc_insertion_point(field_mutable:ApiRequest.getComponent)
  return _msg;
}

// .LoadURDF loadUrdf = 19;
inline bool ApiRequest::has_loadurdf() const {
  return payload_case() == kLoadUrdf;
}
inline bool ApiRequest::_internal_has_loadurdf() const {
  return payload_case() == kLoadUrdf;
}
inline void ApiRequest::set_has_loadurdf() {
  _impl_._oneof_case_[0] = kLoadUrdf;
}
inline void ApiRequest::clear_loadurdf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kLoadUrdf) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.loadurdf_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.loadurdf_);
    }
    clear_has_payload();
  }
}
inline ::LoadURDF* ApiRequest::release_loadurdf() {
  // @@protoc_insertion_point(field_release:ApiRequest.loadUrdf)
  if (payload_case() == kLoadUrdf) {
    clear_has_payload();
    auto* temp = _impl_.payload_.loadurdf_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.loadurdf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LoadURDF& ApiRequest::_internal_loadurdf() const {
  return payload_case() == kLoadUrdf ? *_impl_.payload_.loadurdf_ : reinterpret_cast<::LoadURDF&>(::_LoadURDF_default_instance_);
}
inline const ::LoadURDF& ApiRequest::loadurdf() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.loadUrdf)
  return _internal_loadurdf();
}
inline ::LoadURDF* ApiRequest::unsafe_arena_release_loadurdf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.loadUrdf)
  if (payload_case() == kLoadUrdf) {
    clear_has_payload();
    auto* temp = _impl_.payload_.loadurdf_;
    _impl_.payload_.loadurdf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_loadurdf(::LoadURDF* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_loadurdf();
    _impl_.payload_.loadurdf_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.loadUrdf)
}
inline ::LoadURDF* ApiRequest::_internal_mutable_loadurdf() {
  if (payload_case() != kLoadUrdf) {
    clear_payload();
    set_has_loadurdf();
    _impl_.payload_.loadurdf_ =
        ::google::protobuf::Message::DefaultConstruct<::LoadURDF>(GetArena());
  }
  return _impl_.payload_.loadurdf_;
}
inline ::LoadURDF* ApiRequest::mutable_loadurdf() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::LoadURDF* _msg = _internal_mutable_loadurdf();
  // @@protoc_insertion_point(field_mutable:ApiRequest.loadUrdf)
  return _msg;
}

inline bool ApiRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ApiRequest::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ApiRequest::PayloadCase ApiRequest::payload_case() const {
  return ApiRequest::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ApiRequestResponse

// int64 requestId = 1;
inline void ApiRequestResponse::clear_requestid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requestid_ = ::int64_t{0};
}
inline ::int64_t ApiRequestResponse::requestid() const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.requestId)
  return _internal_requestid();
}
inline void ApiRequestResponse::set_requestid(::int64_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.requestId)
}
inline ::int64_t ApiRequestResponse::_internal_requestid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requestid_;
}
inline void ApiRequestResponse::_internal_set_requestid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requestid_ = value;
}

// int64 actionId = 2;
inline void ApiRequestResponse::clear_actionid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = ::int64_t{0};
}
inline ::int64_t ApiRequestResponse::actionid() const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.actionId)
  return _internal_actionid();
}
inline void ApiRequestResponse::set_actionid(::int64_t value) {
  _internal_set_actionid(value);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.actionId)
}
inline ::int64_t ApiRequestResponse::_internal_actionid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actionid_;
}
inline void ApiRequestResponse::_internal_set_actionid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = value;
}

// bool success = 3;
inline void ApiRequestResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool ApiRequestResponse::success() const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.success)
  return _internal_success();
}
inline void ApiRequestResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.success)
}
inline bool ApiRequestResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ApiRequestResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .EngineStatus status = 4;
inline bool ApiRequestResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ApiRequestResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::EngineStatus& ApiRequestResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::EngineStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::EngineStatus&>(::_EngineStatus_default_instance_);
}
inline const ::EngineStatus& ApiRequestResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.status)
  return _internal_status();
}
inline void ApiRequestResponse::unsafe_arena_set_allocated_status(::EngineStatus* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::EngineStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequestResponse.status)
}
inline ::EngineStatus* ApiRequestResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::EngineStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::EngineStatus* ApiRequestResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApiRequestResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::EngineStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::EngineStatus* ApiRequestResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::EngineStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::EngineStatus*>(p);
  }
  return _impl_.status_;
}
inline ::EngineStatus* ApiRequestResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::EngineStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ApiRequestResponse.status)
  return _msg;
}
inline void ApiRequestResponse::set_allocated_status(::EngineStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::EngineStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:ApiRequestResponse.status)
}

// repeated int64 entity_ids = 5;
inline int ApiRequestResponse::_internal_entity_ids_size() const {
  return _internal_entity_ids().size();
}
inline int ApiRequestResponse::entity_ids_size() const {
  return _internal_entity_ids_size();
}
inline void ApiRequestResponse::clear_entity_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_ids_.Clear();
}
inline ::int64_t ApiRequestResponse::entity_ids(int index) const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.entity_ids)
  return _internal_entity_ids().Get(index);
}
inline void ApiRequestResponse::set_entity_ids(int index, ::int64_t value) {
  _internal_mutable_entity_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.entity_ids)
}
inline void ApiRequestResponse::add_entity_ids(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_entity_ids()->Add(value);
  // @@protoc_insertion_point(field_add:ApiRequestResponse.entity_ids)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& ApiRequestResponse::entity_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ApiRequestResponse.entity_ids)
  return _internal_entity_ids();
}
inline ::google::protobuf::RepeatedField<::int64_t>* ApiRequestResponse::mutable_entity_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ApiRequestResponse.entity_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entity_ids();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
ApiRequestResponse::_internal_entity_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_ids_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* ApiRequestResponse::_internal_mutable_entity_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entity_ids_;
}

// .Component component = 6;
inline bool ApiRequestResponse::has_component() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_ != nullptr);
  return value;
}
inline void ApiRequestResponse::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ != nullptr) _impl_.component_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Component& ApiRequestResponse::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Component* p = _impl_.component_;
  return p != nullptr ? *p : reinterpret_cast<const ::Component&>(::_Component_default_instance_);
}
inline const ::Component& ApiRequestResponse::component() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.component)
  return _internal_component();
}
inline void ApiRequestResponse::unsafe_arena_set_allocated_component(::Component* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_);
  }
  _impl_.component_ = reinterpret_cast<::Component*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequestResponse.component)
}
inline ::Component* ApiRequestResponse::release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Component* released = _impl_.component_;
  _impl_.component_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Component* ApiRequestResponse::unsafe_arena_release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApiRequestResponse.component)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Component* temp = _impl_.component_;
  _impl_.component_ = nullptr;
  return temp;
}
inline ::Component* ApiRequestResponse::_internal_mutable_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Component>(GetArena());
    _impl_.component_ = reinterpret_cast<::Component*>(p);
  }
  return _impl_.component_;
}
inline ::Component* ApiRequestResponse::mutable_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Component* _msg = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:ApiRequestResponse.component)
  return _msg;
}
inline void ApiRequestResponse::set_allocated_component(::Component* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.component_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.component_ = reinterpret_cast<::Component*>(value);
  // @@protoc_insertion_point(field_set_allocated:ApiRequestResponse.component)
}

// repeated .EntityComponentInfo entity_components = 7;
inline int ApiRequestResponse::_internal_entity_components_size() const {
  return _internal_entity_components().size();
}
inline int ApiRequestResponse::entity_components_size() const {
  return _internal_entity_components_size();
}
inline void ApiRequestResponse::clear_entity_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_components_.Clear();
}
inline ::EntityComponentInfo* ApiRequestResponse::mutable_entity_components(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ApiRequestResponse.entity_components)
  return _internal_mutable_entity_components()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>* ApiRequestResponse::mutable_entity_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ApiRequestResponse.entity_components)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entity_components();
}
inline const ::EntityComponentInfo& ApiRequestResponse::entity_components(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.entity_components)
  return _internal_entity_components().Get(index);
}
inline ::EntityComponentInfo* ApiRequestResponse::add_entity_components() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::EntityComponentInfo* _add = _internal_mutable_entity_components()->Add();
  // @@protoc_insertion_point(field_add:ApiRequestResponse.entity_components)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>& ApiRequestResponse::entity_components() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ApiRequestResponse.entity_components)
  return _internal_entity_components();
}
inline const ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>&
ApiRequestResponse::_internal_entity_components() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_components_;
}
inline ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>*
ApiRequestResponse::_internal_mutable_entity_components() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entity_components_;
}

// -------------------------------------------------------------------

// EntityComponentInfo

// int64 entity_id = 1;
inline void EntityComponentInfo::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_ = ::int64_t{0};
}
inline ::int64_t EntityComponentInfo::entity_id() const {
  // @@protoc_insertion_point(field_get:EntityComponentInfo.entity_id)
  return _internal_entity_id();
}
inline void EntityComponentInfo::set_entity_id(::int64_t value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:EntityComponentInfo.entity_id)
}
inline ::int64_t EntityComponentInfo::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_;
}
inline void EntityComponentInfo::_internal_set_entity_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_ = value;
}

// repeated .ComponentType component_types = 2;
inline int EntityComponentInfo::_internal_component_types_size() const {
  return _internal_component_types().size();
}
inline int EntityComponentInfo::component_types_size() const {
  return _internal_component_types_size();
}
inline void EntityComponentInfo::clear_component_types() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_types_.Clear();
}
inline ::ComponentType EntityComponentInfo::component_types(int index) const {
  // @@protoc_insertion_point(field_get:EntityComponentInfo.component_types)
  return static_cast<::ComponentType>(_internal_component_types().Get(index));
}
inline void EntityComponentInfo::set_component_types(int index, ::ComponentType value) {
  _internal_mutable_component_types()->Set(index, value);
  // @@protoc_insertion_point(field_set:EntityComponentInfo.component_types)
}
inline void EntityComponentInfo::add_component_types(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_component_types()->Add(value);
  // @@protoc_insertion_point(field_add:EntityComponentInfo.component_types)
}
inline const ::google::protobuf::RepeatedField<int>& EntityComponentInfo::component_types() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:EntityComponentInfo.component_types)
  return _internal_component_types();
}
inline ::google::protobuf::RepeatedField<int>* EntityComponentInfo::mutable_component_types()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:EntityComponentInfo.component_types)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_component_types();
}
inline const ::google::protobuf::RepeatedField<int>& EntityComponentInfo::_internal_component_types()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.component_types_;
}
inline ::google::protobuf::RepeatedField<int>* EntityComponentInfo::_internal_mutable_component_types() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.component_types_;
}

// -------------------------------------------------------------------

// PositionableComponent

// int64 entityId = 1;
inline void PositionableComponent::clear_entityid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = ::int64_t{0};
}
inline ::int64_t PositionableComponent::entityid() const {
  // @@protoc_insertion_point(field_get:PositionableComponent.entityId)
  return _internal_entityid();
}
inline void PositionableComponent::set_entityid(::int64_t value) {
  _internal_set_entityid(value);
  // @@protoc_insertion_point(field_set:PositionableComponent.entityId)
}
inline ::int64_t PositionableComponent::_internal_entityid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entityid_;
}
inline void PositionableComponent::_internal_set_entityid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = value;
}

// .Vector position = 2;
inline bool PositionableComponent::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void PositionableComponent::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Vector& PositionableComponent::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PositionableComponent::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PositionableComponent.position)
  return _internal_position();
}
inline void PositionableComponent::unsafe_arena_set_allocated_position(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PositionableComponent.position)
}
inline ::Vector* PositionableComponent::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* PositionableComponent::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PositionableComponent.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Vector* PositionableComponent::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.position_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.position_;
}
inline ::Vector* PositionableComponent::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Vector* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:PositionableComponent.position)
  return _msg;
}
inline void PositionableComponent::set_allocated_position(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PositionableComponent.position)
}

// .Vector rotation = 3;
inline bool PositionableComponent::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void PositionableComponent::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Vector& PositionableComponent::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PositionableComponent::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PositionableComponent.rotation)
  return _internal_rotation();
}
inline void PositionableComponent::unsafe_arena_set_allocated_rotation(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PositionableComponent.rotation)
}
inline ::Vector* PositionableComponent::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Vector* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* PositionableComponent::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PositionableComponent.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Vector* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Vector* PositionableComponent::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.rotation_;
}
inline ::Vector* PositionableComponent::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Vector* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:PositionableComponent.rotation)
  return _msg;
}
inline void PositionableComponent::set_allocated_rotation(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PositionableComponent.rotation)
}

// float scale = 4;
inline void PositionableComponent::clear_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = 0;
}
inline float PositionableComponent::scale() const {
  // @@protoc_insertion_point(field_get:PositionableComponent.scale)
  return _internal_scale();
}
inline void PositionableComponent::set_scale(float value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:PositionableComponent.scale)
}
inline float PositionableComponent::_internal_scale() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scale_;
}
inline void PositionableComponent::_internal_set_scale(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = value;
}

// .Vector origin = 5;
inline bool PositionableComponent::has_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.origin_ != nullptr);
  return value;
}
inline void PositionableComponent::clear_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Vector& PositionableComponent::_internal_origin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PositionableComponent::origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PositionableComponent.origin)
  return _internal_origin();
}
inline void PositionableComponent::unsafe_arena_set_allocated_origin(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.origin_);
  }
  _impl_.origin_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PositionableComponent.origin)
}
inline ::Vector* PositionableComponent::release_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Vector* released = _impl_.origin_;
  _impl_.origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* PositionableComponent::unsafe_arena_release_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PositionableComponent.origin)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Vector* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
  return temp;
}
inline ::Vector* PositionableComponent::_internal_mutable_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.origin_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.origin_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.origin_;
}
inline ::Vector* PositionableComponent::mutable_origin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::Vector* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:PositionableComponent.origin)
  return _msg;
}
inline void PositionableComponent::set_allocated_origin(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.origin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.origin_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PositionableComponent.origin)
}

// -------------------------------------------------------------------

// ModelComponent

// int64 entityId = 1;
inline void ModelComponent::clear_entityid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = ::int64_t{0};
}
inline ::int64_t ModelComponent::entityid() const {
  // @@protoc_insertion_point(field_get:ModelComponent.entityId)
  return _internal_entityid();
}
inline void ModelComponent::set_entityid(::int64_t value) {
  _internal_set_entityid(value);
  // @@protoc_insertion_point(field_set:ModelComponent.entityId)
}
inline ::int64_t ModelComponent::_internal_entityid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entityid_;
}
inline void ModelComponent::_internal_set_entityid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = value;
}

// string model_path = 2;
inline void ModelComponent::clear_model_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_path_.ClearToEmpty();
}
inline const std::string& ModelComponent::model_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ModelComponent.model_path)
  return _internal_model_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelComponent::set_model_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ModelComponent.model_path)
}
inline std::string* ModelComponent::mutable_model_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_path();
  // @@protoc_insertion_point(field_mutable:ModelComponent.model_path)
  return _s;
}
inline const std::string& ModelComponent::_internal_model_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_path_.Get();
}
inline void ModelComponent::_internal_set_model_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_path_.Set(value, GetArena());
}
inline std::string* ModelComponent::_internal_mutable_model_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_path_.Mutable( GetArena());
}
inline std::string* ModelComponent::release_model_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ModelComponent.model_path)
  return _impl_.model_path_.Release();
}
inline void ModelComponent::set_allocated_model_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_path_.IsDefault()) {
          _impl_.model_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModelComponent.model_path)
}

// -------------------------------------------------------------------

// Component

// .ComponentType type = 1;
inline void Component::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::ComponentType Component::type() const {
  // @@protoc_insertion_point(field_get:Component.type)
  return _internal_type();
}
inline void Component::set_type(::ComponentType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Component.type)
}
inline ::ComponentType Component::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ComponentType>(_impl_.type_);
}
inline void Component::_internal_set_type(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .PositionableComponent positionable = 2;
inline bool Component::has_positionable() const {
  return component_type_case() == kPositionable;
}
inline bool Component::_internal_has_positionable() const {
  return component_type_case() == kPositionable;
}
inline void Component::set_has_positionable() {
  _impl_._oneof_case_[0] = kPositionable;
}
inline void Component::clear_positionable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (component_type_case() == kPositionable) {
    if (GetArena() == nullptr) {
      delete _impl_.component_type_.positionable_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.component_type_.positionable_);
    }
    clear_has_component_type();
  }
}
inline ::PositionableComponent* Component::release_positionable() {
  // @@protoc_insertion_point(field_release:Component.positionable)
  if (component_type_case() == kPositionable) {
    clear_has_component_type();
    auto* temp = _impl_.component_type_.positionable_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.component_type_.positionable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PositionableComponent& Component::_internal_positionable() const {
  return component_type_case() == kPositionable ? *_impl_.component_type_.positionable_ : reinterpret_cast<::PositionableComponent&>(::_PositionableComponent_default_instance_);
}
inline const ::PositionableComponent& Component::positionable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Component.positionable)
  return _internal_positionable();
}
inline ::PositionableComponent* Component::unsafe_arena_release_positionable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Component.positionable)
  if (component_type_case() == kPositionable) {
    clear_has_component_type();
    auto* temp = _impl_.component_type_.positionable_;
    _impl_.component_type_.positionable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Component::unsafe_arena_set_allocated_positionable(::PositionableComponent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_component_type();
  if (value) {
    set_has_positionable();
    _impl_.component_type_.positionable_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Component.positionable)
}
inline ::PositionableComponent* Component::_internal_mutable_positionable() {
  if (component_type_case() != kPositionable) {
    clear_component_type();
    set_has_positionable();
    _impl_.component_type_.positionable_ =
        ::google::protobuf::Message::DefaultConstruct<::PositionableComponent>(GetArena());
  }
  return _impl_.component_type_.positionable_;
}
inline ::PositionableComponent* Component::mutable_positionable() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PositionableComponent* _msg = _internal_mutable_positionable();
  // @@protoc_insertion_point(field_mutable:Component.positionable)
  return _msg;
}

// .ModelComponent model = 3;
inline bool Component::has_model() const {
  return component_type_case() == kModel;
}
inline bool Component::_internal_has_model() const {
  return component_type_case() == kModel;
}
inline void Component::set_has_model() {
  _impl_._oneof_case_[0] = kModel;
}
inline void Component::clear_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (component_type_case() == kModel) {
    if (GetArena() == nullptr) {
      delete _impl_.component_type_.model_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.component_type_.model_);
    }
    clear_has_component_type();
  }
}
inline ::ModelComponent* Component::release_model() {
  // @@protoc_insertion_point(field_release:Component.model)
  if (component_type_case() == kModel) {
    clear_has_component_type();
    auto* temp = _impl_.component_type_.model_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.component_type_.model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ModelComponent& Component::_internal_model() const {
  return component_type_case() == kModel ? *_impl_.component_type_.model_ : reinterpret_cast<::ModelComponent&>(::_ModelComponent_default_instance_);
}
inline const ::ModelComponent& Component::model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Component.model)
  return _internal_model();
}
inline ::ModelComponent* Component::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Component.model)
  if (component_type_case() == kModel) {
    clear_has_component_type();
    auto* temp = _impl_.component_type_.model_;
    _impl_.component_type_.model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Component::unsafe_arena_set_allocated_model(::ModelComponent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_component_type();
  if (value) {
    set_has_model();
    _impl_.component_type_.model_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Component.model)
}
inline ::ModelComponent* Component::_internal_mutable_model() {
  if (component_type_case() != kModel) {
    clear_component_type();
    set_has_model();
    _impl_.component_type_.model_ =
        ::google::protobuf::Message::DefaultConstruct<::ModelComponent>(GetArena());
  }
  return _impl_.component_type_.model_;
}
inline ::ModelComponent* Component::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ModelComponent* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:Component.model)
  return _msg;
}

inline bool Component::has_component_type() const {
  return component_type_case() != COMPONENT_TYPE_NOT_SET;
}
inline void Component::clear_has_component_type() {
  _impl_._oneof_case_[0] = COMPONENT_TYPE_NOT_SET;
}
inline Component::ComponentTypeCase Component::component_type_case() const {
  return Component::ComponentTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddComponent

// .Component component = 1;
inline bool AddComponent::has_component() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_ != nullptr);
  return value;
}
inline void AddComponent::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ != nullptr) _impl_.component_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Component& AddComponent::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Component* p = _impl_.component_;
  return p != nullptr ? *p : reinterpret_cast<const ::Component&>(::_Component_default_instance_);
}
inline const ::Component& AddComponent::component() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AddComponent.component)
  return _internal_component();
}
inline void AddComponent::unsafe_arena_set_allocated_component(::Component* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_);
  }
  _impl_.component_ = reinterpret_cast<::Component*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AddComponent.component)
}
inline ::Component* AddComponent::release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Component* released = _impl_.component_;
  _impl_.component_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Component* AddComponent::unsafe_arena_release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AddComponent.component)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Component* temp = _impl_.component_;
  _impl_.component_ = nullptr;
  return temp;
}
inline ::Component* AddComponent::_internal_mutable_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Component>(GetArena());
    _impl_.component_ = reinterpret_cast<::Component*>(p);
  }
  return _impl_.component_;
}
inline ::Component* AddComponent::mutable_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Component* _msg = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:AddComponent.component)
  return _msg;
}
inline void AddComponent::set_allocated_component(::Component* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.component_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.component_ = reinterpret_cast<::Component*>(value);
  // @@protoc_insertion_point(field_set_allocated:AddComponent.component)
}

// -------------------------------------------------------------------

// DeleteComponent

// .ComponentType component_type = 1;
inline void DeleteComponent::clear_component_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_type_ = 0;
}
inline ::ComponentType DeleteComponent::component_type() const {
  // @@protoc_insertion_point(field_get:DeleteComponent.component_type)
  return _internal_component_type();
}
inline void DeleteComponent::set_component_type(::ComponentType value) {
  _internal_set_component_type(value);
  // @@protoc_insertion_point(field_set:DeleteComponent.component_type)
}
inline ::ComponentType DeleteComponent::_internal_component_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ComponentType>(_impl_.component_type_);
}
inline void DeleteComponent::_internal_set_component_type(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_type_ = value;
}

// -------------------------------------------------------------------

// EditComponent

// .Component component = 1;
inline bool EditComponent::has_component() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.component_ != nullptr);
  return value;
}
inline void EditComponent::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ != nullptr) _impl_.component_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Component& EditComponent::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Component* p = _impl_.component_;
  return p != nullptr ? *p : reinterpret_cast<const ::Component&>(::_Component_default_instance_);
}
inline const ::Component& EditComponent::component() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:EditComponent.component)
  return _internal_component();
}
inline void EditComponent::unsafe_arena_set_allocated_component(::Component* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_);
  }
  _impl_.component_ = reinterpret_cast<::Component*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EditComponent.component)
}
inline ::Component* EditComponent::release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Component* released = _impl_.component_;
  _impl_.component_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Component* EditComponent::unsafe_arena_release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:EditComponent.component)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Component* temp = _impl_.component_;
  _impl_.component_ = nullptr;
  return temp;
}
inline ::Component* EditComponent::_internal_mutable_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Component>(GetArena());
    _impl_.component_ = reinterpret_cast<::Component*>(p);
  }
  return _impl_.component_;
}
inline ::Component* EditComponent::mutable_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Component* _msg = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:EditComponent.component)
  return _msg;
}
inline void EditComponent::set_allocated_component(::Component* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.component_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.component_ = reinterpret_cast<::Component*>(value);
  // @@protoc_insertion_point(field_set_allocated:EditComponent.component)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MessageType>() {
  return ::MessageType_descriptor();
}
template <>
struct is_proto_enum<::ComponentType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ComponentType>() {
  return ::ComponentType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_protos_2fapi_2eproto_2epb_2eh
