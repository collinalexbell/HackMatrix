// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: protos/api.proto
// Protobuf C++ Version: 5.28.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fapi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fapi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protos_2fapi_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fapi_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_protos_2fapi_2eproto;
class AddVoxels;
struct AddVoxelsDefaultTypeInternal;
extern AddVoxelsDefaultTypeInternal _AddVoxels_default_instance_;
class ApiRequest;
struct ApiRequestDefaultTypeInternal;
extern ApiRequestDefaultTypeInternal _ApiRequest_default_instance_;
class ApiRequestResponse;
struct ApiRequestResponseDefaultTypeInternal;
extern ApiRequestResponseDefaultTypeInternal _ApiRequestResponse_default_instance_;
class ClearVoxels;
struct ClearVoxelsDefaultTypeInternal;
extern ClearVoxelsDefaultTypeInternal _ClearVoxels_default_instance_;
class ConfirmAction;
struct ConfirmActionDefaultTypeInternal;
extern ConfirmActionDefaultTypeInternal _ConfirmAction_default_instance_;
class EngineStatus;
struct EngineStatusDefaultTypeInternal;
extern EngineStatusDefaultTypeInternal _EngineStatus_default_instance_;
class KeyReplay;
struct KeyReplayDefaultTypeInternal;
extern KeyReplayDefaultTypeInternal _KeyReplay_default_instance_;
class KeyReplayEntry;
struct KeyReplayEntryDefaultTypeInternal;
extern KeyReplayEntryDefaultTypeInternal _KeyReplayEntry_default_instance_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class NoPayload;
struct NoPayloadDefaultTypeInternal;
extern NoPayloadDefaultTypeInternal _NoPayload_default_instance_;
class PlayerMove;
struct PlayerMoveDefaultTypeInternal;
extern PlayerMoveDefaultTypeInternal _PlayerMove_default_instance_;
class PointerReplay;
struct PointerReplayDefaultTypeInternal;
extern PointerReplayDefaultTypeInternal _PointerReplay_default_instance_;
class PointerReplayEntry;
struct PointerReplayEntryDefaultTypeInternal;
extern PointerReplayEntryDefaultTypeInternal _PointerReplayEntry_default_instance_;
class Range;
struct RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class TurnKey;
struct TurnKeyDefaultTypeInternal;
extern TurnKeyDefaultTypeInternal _TurnKey_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
class VoxelCoord;
struct VoxelCoordDefaultTypeInternal;
extern VoxelCoordDefaultTypeInternal _VoxelCoord_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum MessageType : int {
  MOVE = 0,
  TURN_KEY = 1,
  PLAYER_MOVE = 2,
  UNFOCUS_WINDOW = 3,
  ADD_VOXELS = 4,
  CLEAR_VOXELS = 5,
  CONFIRM_ACTION = 6,
  QUIT = 7,
  KEY_REPLAY = 8,
  STATUS = 9,
  POINTER_REPLAY = 10,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MessageType_IsValid(int value);
extern const uint32_t MessageType_internal_data_[];
constexpr MessageType MessageType_MIN = static_cast<MessageType>(0);
constexpr MessageType MessageType_MAX = static_cast<MessageType>(10);
constexpr int MessageType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
MessageType_descriptor();
template <typename T>
const std::string& MessageType_Name(T value) {
  static_assert(std::is_same<T, MessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return MessageType_Name(static_cast<MessageType>(value));
}
template <>
inline const std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MessageType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool MessageType_Parse(absl::string_view name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
      MessageType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VoxelCoord final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:VoxelCoord) */ {
 public:
  inline VoxelCoord() : VoxelCoord(nullptr) {}
  ~VoxelCoord() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VoxelCoord(
      ::google::protobuf::internal::ConstantInitialized);

  inline VoxelCoord(const VoxelCoord& from) : VoxelCoord(nullptr, from) {}
  inline VoxelCoord(VoxelCoord&& from) noexcept
      : VoxelCoord(nullptr, std::move(from)) {}
  inline VoxelCoord& operator=(const VoxelCoord& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoxelCoord& operator=(VoxelCoord&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoxelCoord& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoxelCoord* internal_default_instance() {
    return reinterpret_cast<const VoxelCoord*>(
        &_VoxelCoord_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(VoxelCoord& a, VoxelCoord& b) { a.Swap(&b); }
  inline void Swap(VoxelCoord* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoxelCoord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoxelCoord* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<VoxelCoord>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VoxelCoord& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VoxelCoord& from) { VoxelCoord::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VoxelCoord* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "VoxelCoord"; }

 protected:
  explicit VoxelCoord(::google::protobuf::Arena* arena);
  VoxelCoord(::google::protobuf::Arena* arena, const VoxelCoord& from);
  VoxelCoord(::google::protobuf::Arena* arena, VoxelCoord&& from) noexcept
      : VoxelCoord(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:VoxelCoord)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_VoxelCoord_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VoxelCoord& from_msg);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Vector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector(const Vector& from) : Vector(nullptr, from) {}
  inline Vector(Vector&& from) noexcept
      : Vector(nullptr, std::move(from)) {}
  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
        &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Vector& a, Vector& b) { a.Swap(&b); }
  inline void Swap(Vector* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Vector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector& from) { Vector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Vector"; }

 protected:
  explicit Vector(::google::protobuf::Arena* arena);
  Vector(::google::protobuf::Arena* arena, const Vector& from);
  Vector(::google::protobuf::Arena* arena, Vector&& from) noexcept
      : Vector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:Vector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Vector_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector& from_msg);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TurnKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:TurnKey) */ {
 public:
  inline TurnKey() : TurnKey(nullptr) {}
  ~TurnKey() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline TurnKey(const TurnKey& from) : TurnKey(nullptr, from) {}
  inline TurnKey(TurnKey&& from) noexcept
      : TurnKey(nullptr, std::move(from)) {}
  inline TurnKey& operator=(const TurnKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnKey& operator=(TurnKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const TurnKey* internal_default_instance() {
    return reinterpret_cast<const TurnKey*>(
        &_TurnKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(TurnKey& a, TurnKey& b) { a.Swap(&b); }
  inline void Swap(TurnKey* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnKey* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TurnKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnKey& from) { TurnKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TurnKey* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "TurnKey"; }

 protected:
  explicit TurnKey(::google::protobuf::Arena* arena);
  TurnKey(::google::protobuf::Arena* arena, const TurnKey& from);
  TurnKey(::google::protobuf::Arena* arena, TurnKey&& from) noexcept
      : TurnKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOnFieldNumber = 2,
  };
  // bool on = 2;
  void clear_on() ;
  bool on() const;
  void set_on(bool value);

  private:
  bool _internal_on() const;
  void _internal_set_on(bool value);

  public:
  // @@protoc_insertion_point(class_scope:TurnKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TurnKey_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TurnKey& from_msg);
    bool on_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Range final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  ~Range() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Range(
      ::google::protobuf::internal::ConstantInitialized);

  inline Range(const Range& from) : Range(nullptr, from) {}
  inline Range(Range&& from) noexcept
      : Range(nullptr, std::move(from)) {}
  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Range& default_instance() {
    return *internal_default_instance();
  }
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
        &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Range& a, Range& b) { a.Swap(&b); }
  inline void Swap(Range* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Range* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Range>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Range& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Range& from) { Range::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Range* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Range"; }

 protected:
  explicit Range(::google::protobuf::Arena* arena);
  Range(::google::protobuf::Arena* arena, const Range& from);
  Range(::google::protobuf::Arena* arena, Range&& from) noexcept
      : Range(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // float min = 1;
  void clear_min() ;
  float min() const;
  void set_min(float value);

  private:
  float _internal_min() const;
  void _internal_set_min(float value);

  public:
  // float max = 2;
  void clear_max() ;
  float max() const;
  void set_max(float value);

  private:
  float _internal_max() const;
  void _internal_set_max(float value);

  public:
  // @@protoc_insertion_point(class_scope:Range)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Range_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Range& from_msg);
    float min_;
    float max_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PointerReplayEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PointerReplayEntry) */ {
 public:
  inline PointerReplayEntry() : PointerReplayEntry(nullptr) {}
  ~PointerReplayEntry() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointerReplayEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline PointerReplayEntry(const PointerReplayEntry& from) : PointerReplayEntry(nullptr, from) {}
  inline PointerReplayEntry(PointerReplayEntry&& from) noexcept
      : PointerReplayEntry(nullptr, std::move(from)) {}
  inline PointerReplayEntry& operator=(const PointerReplayEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointerReplayEntry& operator=(PointerReplayEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointerReplayEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointerReplayEntry* internal_default_instance() {
    return reinterpret_cast<const PointerReplayEntry*>(
        &_PointerReplayEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PointerReplayEntry& a, PointerReplayEntry& b) { a.Swap(&b); }
  inline void Swap(PointerReplayEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointerReplayEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointerReplayEntry* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PointerReplayEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointerReplayEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointerReplayEntry& from) { PointerReplayEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PointerReplayEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PointerReplayEntry"; }

 protected:
  explicit PointerReplayEntry(::google::protobuf::Arena* arena);
  PointerReplayEntry(::google::protobuf::Arena* arena, const PointerReplayEntry& from);
  PointerReplayEntry(::google::protobuf::Arena* arena, PointerReplayEntry&& from) noexcept
      : PointerReplayEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kButtonFieldNumber = 1,
    kPressedFieldNumber = 2,
    kDelayMsFieldNumber = 3,
  };
  // uint32 button = 1;
  void clear_button() ;
  ::uint32_t button() const;
  void set_button(::uint32_t value);

  private:
  ::uint32_t _internal_button() const;
  void _internal_set_button(::uint32_t value);

  public:
  // bool pressed = 2;
  void clear_pressed() ;
  bool pressed() const;
  void set_pressed(bool value);

  private:
  bool _internal_pressed() const;
  void _internal_set_pressed(bool value);

  public:
  // uint32 delay_ms = 3;
  void clear_delay_ms() ;
  ::uint32_t delay_ms() const;
  void set_delay_ms(::uint32_t value);

  private:
  ::uint32_t _internal_delay_ms() const;
  void _internal_set_delay_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:PointerReplayEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PointerReplayEntry_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PointerReplayEntry& from_msg);
    ::uint32_t button_;
    bool pressed_;
    ::uint32_t delay_ms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class NoPayload final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:NoPayload) */ {
 public:
  inline NoPayload() : NoPayload(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NoPayload(
      ::google::protobuf::internal::ConstantInitialized);

  inline NoPayload(const NoPayload& from) : NoPayload(nullptr, from) {}
  inline NoPayload(NoPayload&& from) noexcept
      : NoPayload(nullptr, std::move(from)) {}
  inline NoPayload& operator=(const NoPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoPayload& operator=(NoPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoPayload* internal_default_instance() {
    return reinterpret_cast<const NoPayload*>(
        &_NoPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NoPayload& a, NoPayload& b) { a.Swap(&b); }
  inline void Swap(NoPayload* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoPayload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoPayload* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<NoPayload>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NoPayload& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NoPayload& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NoPayload"; }

 protected:
  explicit NoPayload(::google::protobuf::Arena* arena);
  NoPayload(::google::protobuf::Arena* arena, const NoPayload& from);
  NoPayload(::google::protobuf::Arena* arena, NoPayload&& from) noexcept
      : NoPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:NoPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NoPayload_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NoPayload& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Move final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Move(
      ::google::protobuf::internal::ConstantInitialized);

  inline Move(const Move& from) : Move(nullptr, from) {}
  inline Move(Move&& from) noexcept
      : Move(nullptr, std::move(from)) {}
  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
        &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Move& a, Move& b) { a.Swap(&b); }
  inline void Swap(Move* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Move>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Move& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Move& from) { Move::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Move* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Move"; }

 protected:
  explicit Move(::google::protobuf::Arena* arena);
  Move(::google::protobuf::Arena* arena, const Move& from);
  Move(::google::protobuf::Arena* arena, Move&& from) noexcept
      : Move(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXDeltaFieldNumber = 1,
    kYDeltaFieldNumber = 2,
    kZDeltaFieldNumber = 3,
    kUnitsPerSecondFieldNumber = 4,
  };
  // float xDelta = 1;
  void clear_xdelta() ;
  float xdelta() const;
  void set_xdelta(float value);

  private:
  float _internal_xdelta() const;
  void _internal_set_xdelta(float value);

  public:
  // float yDelta = 2;
  void clear_ydelta() ;
  float ydelta() const;
  void set_ydelta(float value);

  private:
  float _internal_ydelta() const;
  void _internal_set_ydelta(float value);

  public:
  // float zDelta = 3;
  void clear_zdelta() ;
  float zdelta() const;
  void set_zdelta(float value);

  private:
  float _internal_zdelta() const;
  void _internal_set_zdelta(float value);

  public:
  // float unitsPerSecond = 4;
  void clear_unitspersecond() ;
  float unitspersecond() const;
  void set_unitspersecond(float value);

  private:
  float _internal_unitspersecond() const;
  void _internal_set_unitspersecond(float value);

  public:
  // @@protoc_insertion_point(class_scope:Move)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Move_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Move& from_msg);
    float xdelta_;
    float ydelta_;
    float zdelta_;
    float unitspersecond_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class KeyReplayEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:KeyReplayEntry) */ {
 public:
  inline KeyReplayEntry() : KeyReplayEntry(nullptr) {}
  ~KeyReplayEntry() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyReplayEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyReplayEntry(const KeyReplayEntry& from) : KeyReplayEntry(nullptr, from) {}
  inline KeyReplayEntry(KeyReplayEntry&& from) noexcept
      : KeyReplayEntry(nullptr, std::move(from)) {}
  inline KeyReplayEntry& operator=(const KeyReplayEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyReplayEntry& operator=(KeyReplayEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyReplayEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyReplayEntry* internal_default_instance() {
    return reinterpret_cast<const KeyReplayEntry*>(
        &_KeyReplayEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(KeyReplayEntry& a, KeyReplayEntry& b) { a.Swap(&b); }
  inline void Swap(KeyReplayEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyReplayEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyReplayEntry* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<KeyReplayEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyReplayEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyReplayEntry& from) { KeyReplayEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyReplayEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "KeyReplayEntry"; }

 protected:
  explicit KeyReplayEntry(::google::protobuf::Arena* arena);
  KeyReplayEntry(::google::protobuf::Arena* arena, const KeyReplayEntry& from);
  KeyReplayEntry(::google::protobuf::Arena* arena, KeyReplayEntry&& from) noexcept
      : KeyReplayEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymFieldNumber = 1,
    kDelayMsFieldNumber = 2,
  };
  // string sym = 1;
  void clear_sym() ;
  const std::string& sym() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sym(Arg_&& arg, Args_... args);
  std::string* mutable_sym();
  PROTOBUF_NODISCARD std::string* release_sym();
  void set_allocated_sym(std::string* value);

  private:
  const std::string& _internal_sym() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sym(
      const std::string& value);
  std::string* _internal_mutable_sym();

  public:
  // uint32 delay_ms = 2;
  void clear_delay_ms() ;
  ::uint32_t delay_ms() const;
  void set_delay_ms(::uint32_t value);

  private:
  ::uint32_t _internal_delay_ms() const;
  void _internal_set_delay_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:KeyReplayEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      26, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_KeyReplayEntry_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyReplayEntry& from_msg);
    ::google::protobuf::internal::ArenaStringPtr sym_;
    ::uint32_t delay_ms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ConfirmAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ConfirmAction) */ {
 public:
  inline ConfirmAction() : ConfirmAction(nullptr) {}
  ~ConfirmAction() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConfirmAction(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConfirmAction(const ConfirmAction& from) : ConfirmAction(nullptr, from) {}
  inline ConfirmAction(ConfirmAction&& from) noexcept
      : ConfirmAction(nullptr, std::move(from)) {}
  inline ConfirmAction& operator=(const ConfirmAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmAction& operator=(ConfirmAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmAction* internal_default_instance() {
    return reinterpret_cast<const ConfirmAction*>(
        &_ConfirmAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ConfirmAction& a, ConfirmAction& b) { a.Swap(&b); }
  inline void Swap(ConfirmAction* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmAction* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ConfirmAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConfirmAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConfirmAction& from) { ConfirmAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConfirmAction* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ConfirmAction"; }

 protected:
  explicit ConfirmAction(::google::protobuf::Arena* arena);
  ConfirmAction(::google::protobuf::Arena* arena, const ConfirmAction& from);
  ConfirmAction(::google::protobuf::Arena* arena, ConfirmAction&& from) noexcept
      : ConfirmAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionIdFieldNumber = 1,
  };
  // int64 actionId = 1;
  void clear_actionid() ;
  ::int64_t actionid() const;
  void set_actionid(::int64_t value);

  private:
  ::int64_t _internal_actionid() const;
  void _internal_set_actionid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ConfirmAction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ConfirmAction_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConfirmAction& from_msg);
    ::int64_t actionid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PointerReplay final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PointerReplay) */ {
 public:
  inline PointerReplay() : PointerReplay(nullptr) {}
  ~PointerReplay() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointerReplay(
      ::google::protobuf::internal::ConstantInitialized);

  inline PointerReplay(const PointerReplay& from) : PointerReplay(nullptr, from) {}
  inline PointerReplay(PointerReplay&& from) noexcept
      : PointerReplay(nullptr, std::move(from)) {}
  inline PointerReplay& operator=(const PointerReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointerReplay& operator=(PointerReplay&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointerReplay& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointerReplay* internal_default_instance() {
    return reinterpret_cast<const PointerReplay*>(
        &_PointerReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PointerReplay& a, PointerReplay& b) { a.Swap(&b); }
  inline void Swap(PointerReplay* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointerReplay* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointerReplay* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PointerReplay>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointerReplay& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointerReplay& from) { PointerReplay::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PointerReplay* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PointerReplay"; }

 protected:
  explicit PointerReplay(::google::protobuf::Arena* arena);
  PointerReplay(::google::protobuf::Arena* arena, const PointerReplay& from);
  PointerReplay(::google::protobuf::Arena* arena, PointerReplay&& from) noexcept
      : PointerReplay(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .PointerReplayEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::PointerReplayEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* _internal_mutable_entries();
  public:
  const ::PointerReplayEntry& entries(int index) const;
  ::PointerReplayEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>& entries() const;
  // @@protoc_insertion_point(class_scope:PointerReplay)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PointerReplay_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PointerReplay& from_msg);
    ::google::protobuf::RepeatedPtrField< ::PointerReplayEntry > entries_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PlayerMove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerMove) */ {
 public:
  inline PlayerMove() : PlayerMove(nullptr) {}
  ~PlayerMove() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerMove(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerMove(const PlayerMove& from) : PlayerMove(nullptr, from) {}
  inline PlayerMove(PlayerMove&& from) noexcept
      : PlayerMove(nullptr, std::move(from)) {}
  inline PlayerMove& operator=(const PlayerMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMove& operator=(PlayerMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMove* internal_default_instance() {
    return reinterpret_cast<const PlayerMove*>(
        &_PlayerMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PlayerMove& a, PlayerMove& b) { a.Swap(&b); }
  inline void Swap(PlayerMove* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMove* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PlayerMove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerMove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerMove& from) { PlayerMove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerMove* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlayerMove"; }

 protected:
  explicit PlayerMove(::google::protobuf::Arena* arena);
  PlayerMove(::google::protobuf::Arena* arena, const PlayerMove& from);
  PlayerMove(::google::protobuf::Arena* arena, PlayerMove&& from) noexcept
      : PlayerMove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
    kUnitsPerSecondFieldNumber = 3,
  };
  // .Vector position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::Vector& position() const;
  PROTOBUF_NODISCARD ::Vector* release_position();
  ::Vector* mutable_position();
  void set_allocated_position(::Vector* value);
  void unsafe_arena_set_allocated_position(::Vector* value);
  ::Vector* unsafe_arena_release_position();

  private:
  const ::Vector& _internal_position() const;
  ::Vector* _internal_mutable_position();

  public:
  // .Vector rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::Vector& rotation() const;
  PROTOBUF_NODISCARD ::Vector* release_rotation();
  ::Vector* mutable_rotation();
  void set_allocated_rotation(::Vector* value);
  void unsafe_arena_set_allocated_rotation(::Vector* value);
  ::Vector* unsafe_arena_release_rotation();

  private:
  const ::Vector& _internal_rotation() const;
  ::Vector* _internal_mutable_rotation();

  public:
  // float unitsPerSecond = 3;
  void clear_unitspersecond() ;
  float unitspersecond() const;
  void set_unitspersecond(float value);

  private:
  float _internal_unitspersecond() const;
  void _internal_set_unitspersecond(float value);

  public:
  // @@protoc_insertion_point(class_scope:PlayerMove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerMove_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerMove& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Vector* position_;
    ::Vector* rotation_;
    float unitspersecond_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class KeyReplay final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:KeyReplay) */ {
 public:
  inline KeyReplay() : KeyReplay(nullptr) {}
  ~KeyReplay() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyReplay(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyReplay(const KeyReplay& from) : KeyReplay(nullptr, from) {}
  inline KeyReplay(KeyReplay&& from) noexcept
      : KeyReplay(nullptr, std::move(from)) {}
  inline KeyReplay& operator=(const KeyReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyReplay& operator=(KeyReplay&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyReplay& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyReplay* internal_default_instance() {
    return reinterpret_cast<const KeyReplay*>(
        &_KeyReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(KeyReplay& a, KeyReplay& b) { a.Swap(&b); }
  inline void Swap(KeyReplay* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyReplay* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyReplay* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<KeyReplay>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyReplay& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyReplay& from) { KeyReplay::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyReplay* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "KeyReplay"; }

 protected:
  explicit KeyReplay(::google::protobuf::Arena* arena);
  KeyReplay(::google::protobuf::Arena* arena, const KeyReplay& from);
  KeyReplay(::google::protobuf::Arena* arena, KeyReplay&& from) noexcept
      : KeyReplay(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .KeyReplayEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::KeyReplayEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* _internal_mutable_entries();
  public:
  const ::KeyReplayEntry& entries(int index) const;
  ::KeyReplayEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>& entries() const;
  // @@protoc_insertion_point(class_scope:KeyReplay)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_KeyReplay_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyReplay& from_msg);
    ::google::protobuf::RepeatedPtrField< ::KeyReplayEntry > entries_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EngineStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:EngineStatus) */ {
 public:
  inline EngineStatus() : EngineStatus(nullptr) {}
  ~EngineStatus() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EngineStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline EngineStatus(const EngineStatus& from) : EngineStatus(nullptr, from) {}
  inline EngineStatus(EngineStatus&& from) noexcept
      : EngineStatus(nullptr, std::move(from)) {}
  inline EngineStatus& operator=(const EngineStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineStatus& operator=(EngineStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineStatus* internal_default_instance() {
    return reinterpret_cast<const EngineStatus*>(
        &_EngineStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(EngineStatus& a, EngineStatus& b) { a.Swap(&b); }
  inline void Swap(EngineStatus* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineStatus* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<EngineStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EngineStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EngineStatus& from) { EngineStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EngineStatus* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "EngineStatus"; }

 protected:
  explicit EngineStatus(::google::protobuf::Arena* arena);
  EngineStatus(::google::protobuf::Arena* arena, const EngineStatus& from);
  EngineStatus(::google::protobuf::Arena* arena, EngineStatus&& from) noexcept
      : EngineStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCameraPositionFieldNumber = 4,
    kTotalEntitiesFieldNumber = 1,
    kWaylandAppsFieldNumber = 2,
    kWaylandFocusFieldNumber = 3,
  };
  // .Vector camera_position = 4;
  bool has_camera_position() const;
  void clear_camera_position() ;
  const ::Vector& camera_position() const;
  PROTOBUF_NODISCARD ::Vector* release_camera_position();
  ::Vector* mutable_camera_position();
  void set_allocated_camera_position(::Vector* value);
  void unsafe_arena_set_allocated_camera_position(::Vector* value);
  ::Vector* unsafe_arena_release_camera_position();

  private:
  const ::Vector& _internal_camera_position() const;
  ::Vector* _internal_mutable_camera_position();

  public:
  // uint32 total_entities = 1;
  void clear_total_entities() ;
  ::uint32_t total_entities() const;
  void set_total_entities(::uint32_t value);

  private:
  ::uint32_t _internal_total_entities() const;
  void _internal_set_total_entities(::uint32_t value);

  public:
  // uint32 wayland_apps = 2;
  void clear_wayland_apps() ;
  ::uint32_t wayland_apps() const;
  void set_wayland_apps(::uint32_t value);

  private:
  ::uint32_t _internal_wayland_apps() const;
  void _internal_set_wayland_apps(::uint32_t value);

  public:
  // bool wayland_focus = 3;
  void clear_wayland_focus() ;
  bool wayland_focus() const;
  void set_wayland_focus(bool value);

  private:
  bool _internal_wayland_focus() const;
  void _internal_set_wayland_focus(bool value);

  public:
  // @@protoc_insertion_point(class_scope:EngineStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EngineStatus_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EngineStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Vector* camera_position_;
    ::uint32_t total_entities_;
    ::uint32_t wayland_apps_;
    bool wayland_focus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ClearVoxels final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ClearVoxels) */ {
 public:
  inline ClearVoxels() : ClearVoxels(nullptr) {}
  ~ClearVoxels() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClearVoxels(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClearVoxels(const ClearVoxels& from) : ClearVoxels(nullptr, from) {}
  inline ClearVoxels(ClearVoxels&& from) noexcept
      : ClearVoxels(nullptr, std::move(from)) {}
  inline ClearVoxels& operator=(const ClearVoxels& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearVoxels& operator=(ClearVoxels&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearVoxels& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearVoxels* internal_default_instance() {
    return reinterpret_cast<const ClearVoxels*>(
        &_ClearVoxels_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ClearVoxels& a, ClearVoxels& b) { a.Swap(&b); }
  inline void Swap(ClearVoxels* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearVoxels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearVoxels* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ClearVoxels>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClearVoxels& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClearVoxels& from) { ClearVoxels::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClearVoxels* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ClearVoxels"; }

 protected:
  explicit ClearVoxels(::google::protobuf::Arena* arena);
  ClearVoxels(::google::protobuf::Arena* arena, const ClearVoxels& from);
  ClearVoxels(::google::protobuf::Arena* arena, ClearVoxels&& from) noexcept
      : ClearVoxels(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .Range x = 1;
  bool has_x() const;
  void clear_x() ;
  const ::Range& x() const;
  PROTOBUF_NODISCARD ::Range* release_x();
  ::Range* mutable_x();
  void set_allocated_x(::Range* value);
  void unsafe_arena_set_allocated_x(::Range* value);
  ::Range* unsafe_arena_release_x();

  private:
  const ::Range& _internal_x() const;
  ::Range* _internal_mutable_x();

  public:
  // .Range y = 2;
  bool has_y() const;
  void clear_y() ;
  const ::Range& y() const;
  PROTOBUF_NODISCARD ::Range* release_y();
  ::Range* mutable_y();
  void set_allocated_y(::Range* value);
  void unsafe_arena_set_allocated_y(::Range* value);
  ::Range* unsafe_arena_release_y();

  private:
  const ::Range& _internal_y() const;
  ::Range* _internal_mutable_y();

  public:
  // .Range z = 3;
  bool has_z() const;
  void clear_z() ;
  const ::Range& z() const;
  PROTOBUF_NODISCARD ::Range* release_z();
  ::Range* mutable_z();
  void set_allocated_z(::Range* value);
  void unsafe_arena_set_allocated_z(::Range* value);
  ::Range* unsafe_arena_release_z();

  private:
  const ::Range& _internal_z() const;
  ::Range* _internal_mutable_z();

  public:
  // @@protoc_insertion_point(class_scope:ClearVoxels)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ClearVoxels_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClearVoxels& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Range* x_;
    ::Range* y_;
    ::Range* z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class AddVoxels final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AddVoxels) */ {
 public:
  inline AddVoxels() : AddVoxels(nullptr) {}
  ~AddVoxels() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddVoxels(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddVoxels(const AddVoxels& from) : AddVoxels(nullptr, from) {}
  inline AddVoxels(AddVoxels&& from) noexcept
      : AddVoxels(nullptr, std::move(from)) {}
  inline AddVoxels& operator=(const AddVoxels& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddVoxels& operator=(AddVoxels&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddVoxels& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddVoxels* internal_default_instance() {
    return reinterpret_cast<const AddVoxels*>(
        &_AddVoxels_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(AddVoxels& a, AddVoxels& b) { a.Swap(&b); }
  inline void Swap(AddVoxels* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddVoxels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddVoxels* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AddVoxels>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddVoxels& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddVoxels& from) { AddVoxels::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddVoxels* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "AddVoxels"; }

 protected:
  explicit AddVoxels(::google::protobuf::Arena* arena);
  AddVoxels(::google::protobuf::Arena* arena, const AddVoxels& from);
  AddVoxels(::google::protobuf::Arena* arena, AddVoxels&& from) noexcept
      : AddVoxels(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVoxelsFieldNumber = 1,
    kColorFieldNumber = 4,
    kReplaceFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // repeated .VoxelCoord voxels = 1;
  int voxels_size() const;
  private:
  int _internal_voxels_size() const;

  public:
  void clear_voxels() ;
  ::VoxelCoord* mutable_voxels(int index);
  ::google::protobuf::RepeatedPtrField<::VoxelCoord>* mutable_voxels();

  private:
  const ::google::protobuf::RepeatedPtrField<::VoxelCoord>& _internal_voxels() const;
  ::google::protobuf::RepeatedPtrField<::VoxelCoord>* _internal_mutable_voxels();
  public:
  const ::VoxelCoord& voxels(int index) const;
  ::VoxelCoord* add_voxels();
  const ::google::protobuf::RepeatedPtrField<::VoxelCoord>& voxels() const;
  // .Vector color = 4;
  bool has_color() const;
  void clear_color() ;
  const ::Vector& color() const;
  PROTOBUF_NODISCARD ::Vector* release_color();
  ::Vector* mutable_color();
  void set_allocated_color(::Vector* value);
  void unsafe_arena_set_allocated_color(::Vector* value);
  ::Vector* unsafe_arena_release_color();

  private:
  const ::Vector& _internal_color() const;
  ::Vector* _internal_mutable_color();

  public:
  // bool replace = 2;
  void clear_replace() ;
  bool replace() const;
  void set_replace(bool value);

  private:
  bool _internal_replace() const;
  void _internal_set_replace(bool value);

  public:
  // float size = 3;
  void clear_size() ;
  float size() const;
  void set_size(float value);

  private:
  float _internal_size() const;
  void _internal_set_size(float value);

  public:
  // @@protoc_insertion_point(class_scope:AddVoxels)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AddVoxels_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AddVoxels& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::VoxelCoord > voxels_;
    ::Vector* color_;
    bool replace_;
    float size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ApiRequestResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ApiRequestResponse) */ {
 public:
  inline ApiRequestResponse() : ApiRequestResponse(nullptr) {}
  ~ApiRequestResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApiRequestResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApiRequestResponse(const ApiRequestResponse& from) : ApiRequestResponse(nullptr, from) {}
  inline ApiRequestResponse(ApiRequestResponse&& from) noexcept
      : ApiRequestResponse(nullptr, std::move(from)) {}
  inline ApiRequestResponse& operator=(const ApiRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiRequestResponse& operator=(ApiRequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiRequestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiRequestResponse* internal_default_instance() {
    return reinterpret_cast<const ApiRequestResponse*>(
        &_ApiRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ApiRequestResponse& a, ApiRequestResponse& b) { a.Swap(&b); }
  inline void Swap(ApiRequestResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiRequestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiRequestResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ApiRequestResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApiRequestResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApiRequestResponse& from) { ApiRequestResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ApiRequestResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ApiRequestResponse"; }

 protected:
  explicit ApiRequestResponse(::google::protobuf::Arena* arena);
  ApiRequestResponse(::google::protobuf::Arena* arena, const ApiRequestResponse& from);
  ApiRequestResponse(::google::protobuf::Arena* arena, ApiRequestResponse&& from) noexcept
      : ApiRequestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kActionIdFieldNumber = 2,
    kSuccessFieldNumber = 3,
  };
  // .EngineStatus status = 4;
  bool has_status() const;
  void clear_status() ;
  const ::EngineStatus& status() const;
  PROTOBUF_NODISCARD ::EngineStatus* release_status();
  ::EngineStatus* mutable_status();
  void set_allocated_status(::EngineStatus* value);
  void unsafe_arena_set_allocated_status(::EngineStatus* value);
  ::EngineStatus* unsafe_arena_release_status();

  private:
  const ::EngineStatus& _internal_status() const;
  ::EngineStatus* _internal_mutable_status();

  public:
  // int64 requestId = 1;
  void clear_requestid() ;
  ::int64_t requestid() const;
  void set_requestid(::int64_t value);

  private:
  ::int64_t _internal_requestid() const;
  void _internal_set_requestid(::int64_t value);

  public:
  // int64 actionId = 2;
  void clear_actionid() ;
  ::int64_t actionid() const;
  void set_actionid(::int64_t value);

  private:
  ::int64_t _internal_actionid() const;
  void _internal_set_actionid(::int64_t value);

  public:
  // bool success = 3;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ApiRequestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ApiRequestResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApiRequestResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::EngineStatus* status_;
    ::int64_t requestid_;
    ::int64_t actionid_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ApiRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ApiRequest) */ {
 public:
  inline ApiRequest() : ApiRequest(nullptr) {}
  ~ApiRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApiRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApiRequest(const ApiRequest& from) : ApiRequest(nullptr, from) {}
  inline ApiRequest(ApiRequest&& from) noexcept
      : ApiRequest(nullptr, std::move(from)) {}
  inline ApiRequest& operator=(const ApiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiRequest& operator=(ApiRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiRequest& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kMove = 3,
    kTurnKey = 4,
    kPlayerMove = 5,
    kNoPayload = 6,
    kAddVoxels = 7,
    kClearVoxels = 8,
    kConfirmAction = 9,
    kKeyReplay = 10,
    kPointerReplay = 11,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const ApiRequest* internal_default_instance() {
    return reinterpret_cast<const ApiRequest*>(
        &_ApiRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ApiRequest& a, ApiRequest& b) { a.Swap(&b); }
  inline void Swap(ApiRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ApiRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApiRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApiRequest& from) { ApiRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ApiRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ApiRequest"; }

 protected:
  explicit ApiRequest(::google::protobuf::Arena* arena);
  ApiRequest(::google::protobuf::Arena* arena, const ApiRequest& from);
  ApiRequest(::google::protobuf::Arena* arena, ApiRequest&& from) noexcept
      : ApiRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kMoveFieldNumber = 3,
    kTurnKeyFieldNumber = 4,
    kPlayerMoveFieldNumber = 5,
    kNoPayloadFieldNumber = 6,
    kAddVoxelsFieldNumber = 7,
    kClearVoxelsFieldNumber = 8,
    kConfirmActionFieldNumber = 9,
    kKeyReplayFieldNumber = 10,
    kPointerReplayFieldNumber = 11,
  };
  // int64 entityId = 1;
  void clear_entityid() ;
  ::int64_t entityid() const;
  void set_entityid(::int64_t value);

  private:
  ::int64_t _internal_entityid() const;
  void _internal_set_entityid(::int64_t value);

  public:
  // .MessageType type = 2;
  void clear_type() ;
  ::MessageType type() const;
  void set_type(::MessageType value);

  private:
  ::MessageType _internal_type() const;
  void _internal_set_type(::MessageType value);

  public:
  // .Move move = 3;
  bool has_move() const;
  private:
  bool _internal_has_move() const;

  public:
  void clear_move() ;
  const ::Move& move() const;
  PROTOBUF_NODISCARD ::Move* release_move();
  ::Move* mutable_move();
  void set_allocated_move(::Move* value);
  void unsafe_arena_set_allocated_move(::Move* value);
  ::Move* unsafe_arena_release_move();

  private:
  const ::Move& _internal_move() const;
  ::Move* _internal_mutable_move();

  public:
  // .TurnKey turnKey = 4;
  bool has_turnkey() const;
  private:
  bool _internal_has_turnkey() const;

  public:
  void clear_turnkey() ;
  const ::TurnKey& turnkey() const;
  PROTOBUF_NODISCARD ::TurnKey* release_turnkey();
  ::TurnKey* mutable_turnkey();
  void set_allocated_turnkey(::TurnKey* value);
  void unsafe_arena_set_allocated_turnkey(::TurnKey* value);
  ::TurnKey* unsafe_arena_release_turnkey();

  private:
  const ::TurnKey& _internal_turnkey() const;
  ::TurnKey* _internal_mutable_turnkey();

  public:
  // .PlayerMove playerMove = 5;
  bool has_playermove() const;
  private:
  bool _internal_has_playermove() const;

  public:
  void clear_playermove() ;
  const ::PlayerMove& playermove() const;
  PROTOBUF_NODISCARD ::PlayerMove* release_playermove();
  ::PlayerMove* mutable_playermove();
  void set_allocated_playermove(::PlayerMove* value);
  void unsafe_arena_set_allocated_playermove(::PlayerMove* value);
  ::PlayerMove* unsafe_arena_release_playermove();

  private:
  const ::PlayerMove& _internal_playermove() const;
  ::PlayerMove* _internal_mutable_playermove();

  public:
  // .NoPayload noPayload = 6;
  bool has_nopayload() const;
  private:
  bool _internal_has_nopayload() const;

  public:
  void clear_nopayload() ;
  const ::NoPayload& nopayload() const;
  PROTOBUF_NODISCARD ::NoPayload* release_nopayload();
  ::NoPayload* mutable_nopayload();
  void set_allocated_nopayload(::NoPayload* value);
  void unsafe_arena_set_allocated_nopayload(::NoPayload* value);
  ::NoPayload* unsafe_arena_release_nopayload();

  private:
  const ::NoPayload& _internal_nopayload() const;
  ::NoPayload* _internal_mutable_nopayload();

  public:
  // .AddVoxels addVoxels = 7;
  bool has_addvoxels() const;
  private:
  bool _internal_has_addvoxels() const;

  public:
  void clear_addvoxels() ;
  const ::AddVoxels& addvoxels() const;
  PROTOBUF_NODISCARD ::AddVoxels* release_addvoxels();
  ::AddVoxels* mutable_addvoxels();
  void set_allocated_addvoxels(::AddVoxels* value);
  void unsafe_arena_set_allocated_addvoxels(::AddVoxels* value);
  ::AddVoxels* unsafe_arena_release_addvoxels();

  private:
  const ::AddVoxels& _internal_addvoxels() const;
  ::AddVoxels* _internal_mutable_addvoxels();

  public:
  // .ClearVoxels clearVoxels = 8;
  bool has_clearvoxels() const;
  private:
  bool _internal_has_clearvoxels() const;

  public:
  void clear_clearvoxels() ;
  const ::ClearVoxels& clearvoxels() const;
  PROTOBUF_NODISCARD ::ClearVoxels* release_clearvoxels();
  ::ClearVoxels* mutable_clearvoxels();
  void set_allocated_clearvoxels(::ClearVoxels* value);
  void unsafe_arena_set_allocated_clearvoxels(::ClearVoxels* value);
  ::ClearVoxels* unsafe_arena_release_clearvoxels();

  private:
  const ::ClearVoxels& _internal_clearvoxels() const;
  ::ClearVoxels* _internal_mutable_clearvoxels();

  public:
  // .ConfirmAction confirmAction = 9;
  bool has_confirmaction() const;
  private:
  bool _internal_has_confirmaction() const;

  public:
  void clear_confirmaction() ;
  const ::ConfirmAction& confirmaction() const;
  PROTOBUF_NODISCARD ::ConfirmAction* release_confirmaction();
  ::ConfirmAction* mutable_confirmaction();
  void set_allocated_confirmaction(::ConfirmAction* value);
  void unsafe_arena_set_allocated_confirmaction(::ConfirmAction* value);
  ::ConfirmAction* unsafe_arena_release_confirmaction();

  private:
  const ::ConfirmAction& _internal_confirmaction() const;
  ::ConfirmAction* _internal_mutable_confirmaction();

  public:
  // .KeyReplay keyReplay = 10;
  bool has_keyreplay() const;
  private:
  bool _internal_has_keyreplay() const;

  public:
  void clear_keyreplay() ;
  const ::KeyReplay& keyreplay() const;
  PROTOBUF_NODISCARD ::KeyReplay* release_keyreplay();
  ::KeyReplay* mutable_keyreplay();
  void set_allocated_keyreplay(::KeyReplay* value);
  void unsafe_arena_set_allocated_keyreplay(::KeyReplay* value);
  ::KeyReplay* unsafe_arena_release_keyreplay();

  private:
  const ::KeyReplay& _internal_keyreplay() const;
  ::KeyReplay* _internal_mutable_keyreplay();

  public:
  // .PointerReplay pointerReplay = 11;
  bool has_pointerreplay() const;
  private:
  bool _internal_has_pointerreplay() const;

  public:
  void clear_pointerreplay() ;
  const ::PointerReplay& pointerreplay() const;
  PROTOBUF_NODISCARD ::PointerReplay* release_pointerreplay();
  ::PointerReplay* mutable_pointerreplay();
  void set_allocated_pointerreplay(::PointerReplay* value);
  void unsafe_arena_set_allocated_pointerreplay(::PointerReplay* value);
  ::PointerReplay* unsafe_arena_release_pointerreplay();

  private:
  const ::PointerReplay& _internal_pointerreplay() const;
  ::PointerReplay* _internal_mutable_pointerreplay();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ApiRequest)
 private:
  class _Internal;
  void set_has_move();
  void set_has_turnkey();
  void set_has_playermove();
  void set_has_nopayload();
  void set_has_addvoxels();
  void set_has_clearvoxels();
  void set_has_confirmaction();
  void set_has_keyreplay();
  void set_has_pointerreplay();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 11, 9,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ApiRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApiRequest& from_msg);
    ::int64_t entityid_;
    int type_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::Move* move_;
      ::TurnKey* turnkey_;
      ::PlayerMove* playermove_;
      ::NoPayload* nopayload_;
      ::AddVoxels* addvoxels_;
      ::ClearVoxels* clearvoxels_;
      ::ConfirmAction* confirmaction_;
      ::KeyReplay* keyreplay_;
      ::PointerReplay* pointerreplay_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NoPayload

// -------------------------------------------------------------------

// Vector

// float x = 1;
inline void Vector::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Vector::x() const {
  // @@protoc_insertion_point(field_get:Vector.x)
  return _internal_x();
}
inline void Vector::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Vector.x)
}
inline float Vector::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Vector::y() const {
  // @@protoc_insertion_point(field_get:Vector.y)
  return _internal_y();
}
inline void Vector::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Vector.y)
}
inline float Vector::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Vector::z() const {
  // @@protoc_insertion_point(field_get:Vector.z)
  return _internal_z();
}
inline void Vector::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Vector.z)
}
inline float Vector::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vector::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Range

// float min = 1;
inline void Range::clear_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = 0;
}
inline float Range::min() const {
  // @@protoc_insertion_point(field_get:Range.min)
  return _internal_min();
}
inline void Range::set_min(float value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:Range.min)
}
inline float Range::_internal_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_;
}
inline void Range::_internal_set_min(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = value;
}

// float max = 2;
inline void Range::clear_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = 0;
}
inline float Range::max() const {
  // @@protoc_insertion_point(field_get:Range.max)
  return _internal_max();
}
inline void Range::set_max(float value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:Range.max)
}
inline float Range::_internal_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_;
}
inline void Range::_internal_set_max(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = value;
}

// -------------------------------------------------------------------

// PlayerMove

// .Vector position = 1;
inline bool PlayerMove::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void PlayerMove::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Vector& PlayerMove::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PlayerMove::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMove.position)
  return _internal_position();
}
inline void PlayerMove::unsafe_arena_set_allocated_position(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMove.position)
}
inline ::Vector* PlayerMove::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* PlayerMove::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlayerMove.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Vector* PlayerMove::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.position_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.position_;
}
inline ::Vector* PlayerMove::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Vector* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:PlayerMove.position)
  return _msg;
}
inline void PlayerMove::set_allocated_position(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMove.position)
}

// .Vector rotation = 2;
inline bool PlayerMove::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void PlayerMove::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Vector& PlayerMove::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PlayerMove::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMove.rotation)
  return _internal_rotation();
}
inline void PlayerMove::unsafe_arena_set_allocated_rotation(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMove.rotation)
}
inline ::Vector* PlayerMove::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Vector* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* PlayerMove::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlayerMove.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Vector* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Vector* PlayerMove::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.rotation_;
}
inline ::Vector* PlayerMove::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Vector* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:PlayerMove.rotation)
  return _msg;
}
inline void PlayerMove::set_allocated_rotation(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMove.rotation)
}

// float unitsPerSecond = 3;
inline void PlayerMove::clear_unitspersecond() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = 0;
}
inline float PlayerMove::unitspersecond() const {
  // @@protoc_insertion_point(field_get:PlayerMove.unitsPerSecond)
  return _internal_unitspersecond();
}
inline void PlayerMove::set_unitspersecond(float value) {
  _internal_set_unitspersecond(value);
  // @@protoc_insertion_point(field_set:PlayerMove.unitsPerSecond)
}
inline float PlayerMove::_internal_unitspersecond() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unitspersecond_;
}
inline void PlayerMove::_internal_set_unitspersecond(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = value;
}

// -------------------------------------------------------------------

// VoxelCoord

// float x = 1;
inline void VoxelCoord::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float VoxelCoord::x() const {
  // @@protoc_insertion_point(field_get:VoxelCoord.x)
  return _internal_x();
}
inline void VoxelCoord::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:VoxelCoord.x)
}
inline float VoxelCoord::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void VoxelCoord::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void VoxelCoord::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float VoxelCoord::y() const {
  // @@protoc_insertion_point(field_get:VoxelCoord.y)
  return _internal_y();
}
inline void VoxelCoord::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:VoxelCoord.y)
}
inline float VoxelCoord::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void VoxelCoord::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void VoxelCoord::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float VoxelCoord::z() const {
  // @@protoc_insertion_point(field_get:VoxelCoord.z)
  return _internal_z();
}
inline void VoxelCoord::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:VoxelCoord.z)
}
inline float VoxelCoord::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void VoxelCoord::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// AddVoxels

// repeated .VoxelCoord voxels = 1;
inline int AddVoxels::_internal_voxels_size() const {
  return _internal_voxels().size();
}
inline int AddVoxels::voxels_size() const {
  return _internal_voxels_size();
}
inline void AddVoxels::clear_voxels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.voxels_.Clear();
}
inline ::VoxelCoord* AddVoxels::mutable_voxels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:AddVoxels.voxels)
  return _internal_mutable_voxels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::VoxelCoord>* AddVoxels::mutable_voxels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:AddVoxels.voxels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_voxels();
}
inline const ::VoxelCoord& AddVoxels::voxels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AddVoxels.voxels)
  return _internal_voxels().Get(index);
}
inline ::VoxelCoord* AddVoxels::add_voxels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::VoxelCoord* _add = _internal_mutable_voxels()->Add();
  // @@protoc_insertion_point(field_add:AddVoxels.voxels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::VoxelCoord>& AddVoxels::voxels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:AddVoxels.voxels)
  return _internal_voxels();
}
inline const ::google::protobuf::RepeatedPtrField<::VoxelCoord>&
AddVoxels::_internal_voxels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.voxels_;
}
inline ::google::protobuf::RepeatedPtrField<::VoxelCoord>*
AddVoxels::_internal_mutable_voxels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.voxels_;
}

// bool replace = 2;
inline void AddVoxels::clear_replace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replace_ = false;
}
inline bool AddVoxels::replace() const {
  // @@protoc_insertion_point(field_get:AddVoxels.replace)
  return _internal_replace();
}
inline void AddVoxels::set_replace(bool value) {
  _internal_set_replace(value);
  // @@protoc_insertion_point(field_set:AddVoxels.replace)
}
inline bool AddVoxels::_internal_replace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replace_;
}
inline void AddVoxels::_internal_set_replace(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replace_ = value;
}

// float size = 3;
inline void AddVoxels::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
}
inline float AddVoxels::size() const {
  // @@protoc_insertion_point(field_get:AddVoxels.size)
  return _internal_size();
}
inline void AddVoxels::set_size(float value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:AddVoxels.size)
}
inline float AddVoxels::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void AddVoxels::_internal_set_size(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// .Vector color = 4;
inline bool AddVoxels::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void AddVoxels::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Vector& AddVoxels::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& AddVoxels::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AddVoxels.color)
  return _internal_color();
}
inline void AddVoxels::unsafe_arena_set_allocated_color(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AddVoxels.color)
}
inline ::Vector* AddVoxels::release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* AddVoxels::unsafe_arena_release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AddVoxels.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Vector* AddVoxels::_internal_mutable_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.color_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.color_;
}
inline ::Vector* AddVoxels::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Vector* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:AddVoxels.color)
  return _msg;
}
inline void AddVoxels::set_allocated_color(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:AddVoxels.color)
}

// -------------------------------------------------------------------

// ClearVoxels

// .Range x = 1;
inline bool ClearVoxels::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline void ClearVoxels::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Range& ClearVoxels::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Range* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::Range&>(::_Range_default_instance_);
}
inline const ::Range& ClearVoxels::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClearVoxels.x)
  return _internal_x();
}
inline void ClearVoxels::unsafe_arena_set_allocated_x(::Range* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClearVoxels.x)
}
inline ::Range* ClearVoxels::release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Range* released = _impl_.x_;
  _impl_.x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Range* ClearVoxels::unsafe_arena_release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClearVoxels.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Range* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::Range* ClearVoxels::_internal_mutable_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Range>(GetArena());
    _impl_.x_ = reinterpret_cast<::Range*>(p);
  }
  return _impl_.x_;
}
inline ::Range* ClearVoxels::mutable_x() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Range* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:ClearVoxels.x)
  return _msg;
}
inline void ClearVoxels::set_allocated_x(::Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClearVoxels.x)
}

// .Range y = 2;
inline bool ClearVoxels::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline void ClearVoxels::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Range& ClearVoxels::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Range* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::Range&>(::_Range_default_instance_);
}
inline const ::Range& ClearVoxels::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClearVoxels.y)
  return _internal_y();
}
inline void ClearVoxels::unsafe_arena_set_allocated_y(::Range* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClearVoxels.y)
}
inline ::Range* ClearVoxels::release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Range* released = _impl_.y_;
  _impl_.y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Range* ClearVoxels::unsafe_arena_release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClearVoxels.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Range* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::Range* ClearVoxels::_internal_mutable_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Range>(GetArena());
    _impl_.y_ = reinterpret_cast<::Range*>(p);
  }
  return _impl_.y_;
}
inline ::Range* ClearVoxels::mutable_y() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Range* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:ClearVoxels.y)
  return _msg;
}
inline void ClearVoxels::set_allocated_y(::Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClearVoxels.y)
}

// .Range z = 3;
inline bool ClearVoxels::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline void ClearVoxels::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Range& ClearVoxels::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Range* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::Range&>(::_Range_default_instance_);
}
inline const ::Range& ClearVoxels::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClearVoxels.z)
  return _internal_z();
}
inline void ClearVoxels::unsafe_arena_set_allocated_z(::Range* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClearVoxels.z)
}
inline ::Range* ClearVoxels::release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Range* released = _impl_.z_;
  _impl_.z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Range* ClearVoxels::unsafe_arena_release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClearVoxels.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Range* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::Range* ClearVoxels::_internal_mutable_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Range>(GetArena());
    _impl_.z_ = reinterpret_cast<::Range*>(p);
  }
  return _impl_.z_;
}
inline ::Range* ClearVoxels::mutable_z() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::Range* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:ClearVoxels.z)
  return _msg;
}
inline void ClearVoxels::set_allocated_z(::Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClearVoxels.z)
}

// -------------------------------------------------------------------

// ConfirmAction

// int64 actionId = 1;
inline void ConfirmAction::clear_actionid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = ::int64_t{0};
}
inline ::int64_t ConfirmAction::actionid() const {
  // @@protoc_insertion_point(field_get:ConfirmAction.actionId)
  return _internal_actionid();
}
inline void ConfirmAction::set_actionid(::int64_t value) {
  _internal_set_actionid(value);
  // @@protoc_insertion_point(field_set:ConfirmAction.actionId)
}
inline ::int64_t ConfirmAction::_internal_actionid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actionid_;
}
inline void ConfirmAction::_internal_set_actionid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = value;
}

// -------------------------------------------------------------------

// KeyReplayEntry

// string sym = 1;
inline void KeyReplayEntry::clear_sym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.ClearToEmpty();
}
inline const std::string& KeyReplayEntry::sym() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KeyReplayEntry.sym)
  return _internal_sym();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyReplayEntry::set_sym(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KeyReplayEntry.sym)
}
inline std::string* KeyReplayEntry::mutable_sym() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sym();
  // @@protoc_insertion_point(field_mutable:KeyReplayEntry.sym)
  return _s;
}
inline const std::string& KeyReplayEntry::_internal_sym() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sym_.Get();
}
inline void KeyReplayEntry::_internal_set_sym(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.Set(value, GetArena());
}
inline std::string* KeyReplayEntry::_internal_mutable_sym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sym_.Mutable( GetArena());
}
inline std::string* KeyReplayEntry::release_sym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:KeyReplayEntry.sym)
  return _impl_.sym_.Release();
}
inline void KeyReplayEntry::set_allocated_sym(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sym_.IsDefault()) {
          _impl_.sym_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KeyReplayEntry.sym)
}

// uint32 delay_ms = 2;
inline void KeyReplayEntry::clear_delay_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = 0u;
}
inline ::uint32_t KeyReplayEntry::delay_ms() const {
  // @@protoc_insertion_point(field_get:KeyReplayEntry.delay_ms)
  return _internal_delay_ms();
}
inline void KeyReplayEntry::set_delay_ms(::uint32_t value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:KeyReplayEntry.delay_ms)
}
inline ::uint32_t KeyReplayEntry::_internal_delay_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_ms_;
}
inline void KeyReplayEntry::_internal_set_delay_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = value;
}

// -------------------------------------------------------------------

// KeyReplay

// repeated .KeyReplayEntry entries = 1;
inline int KeyReplay::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int KeyReplay::entries_size() const {
  return _internal_entries_size();
}
inline void KeyReplay::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::KeyReplayEntry* KeyReplay::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:KeyReplay.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* KeyReplay::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:KeyReplay.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::KeyReplayEntry& KeyReplay::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KeyReplay.entries)
  return _internal_entries().Get(index);
}
inline ::KeyReplayEntry* KeyReplay::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::KeyReplayEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:KeyReplay.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>& KeyReplay::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:KeyReplay.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>&
KeyReplay::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>*
KeyReplay::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// PointerReplayEntry

// uint32 button = 1;
inline void PointerReplayEntry::clear_button() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.button_ = 0u;
}
inline ::uint32_t PointerReplayEntry::button() const {
  // @@protoc_insertion_point(field_get:PointerReplayEntry.button)
  return _internal_button();
}
inline void PointerReplayEntry::set_button(::uint32_t value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:PointerReplayEntry.button)
}
inline ::uint32_t PointerReplayEntry::_internal_button() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.button_;
}
inline void PointerReplayEntry::_internal_set_button(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.button_ = value;
}

// bool pressed = 2;
inline void PointerReplayEntry::clear_pressed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pressed_ = false;
}
inline bool PointerReplayEntry::pressed() const {
  // @@protoc_insertion_point(field_get:PointerReplayEntry.pressed)
  return _internal_pressed();
}
inline void PointerReplayEntry::set_pressed(bool value) {
  _internal_set_pressed(value);
  // @@protoc_insertion_point(field_set:PointerReplayEntry.pressed)
}
inline bool PointerReplayEntry::_internal_pressed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pressed_;
}
inline void PointerReplayEntry::_internal_set_pressed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pressed_ = value;
}

// uint32 delay_ms = 3;
inline void PointerReplayEntry::clear_delay_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = 0u;
}
inline ::uint32_t PointerReplayEntry::delay_ms() const {
  // @@protoc_insertion_point(field_get:PointerReplayEntry.delay_ms)
  return _internal_delay_ms();
}
inline void PointerReplayEntry::set_delay_ms(::uint32_t value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:PointerReplayEntry.delay_ms)
}
inline ::uint32_t PointerReplayEntry::_internal_delay_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_ms_;
}
inline void PointerReplayEntry::_internal_set_delay_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = value;
}

// -------------------------------------------------------------------

// PointerReplay

// repeated .PointerReplayEntry entries = 1;
inline int PointerReplay::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int PointerReplay::entries_size() const {
  return _internal_entries_size();
}
inline void PointerReplay::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::PointerReplayEntry* PointerReplay::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PointerReplay.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* PointerReplay::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:PointerReplay.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::PointerReplayEntry& PointerReplay::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PointerReplay.entries)
  return _internal_entries().Get(index);
}
inline ::PointerReplayEntry* PointerReplay::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::PointerReplayEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:PointerReplay.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>& PointerReplay::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PointerReplay.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>&
PointerReplay::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>*
PointerReplay::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// EngineStatus

// uint32 total_entities = 1;
inline void EngineStatus::clear_total_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_entities_ = 0u;
}
inline ::uint32_t EngineStatus::total_entities() const {
  // @@protoc_insertion_point(field_get:EngineStatus.total_entities)
  return _internal_total_entities();
}
inline void EngineStatus::set_total_entities(::uint32_t value) {
  _internal_set_total_entities(value);
  // @@protoc_insertion_point(field_set:EngineStatus.total_entities)
}
inline ::uint32_t EngineStatus::_internal_total_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_entities_;
}
inline void EngineStatus::_internal_set_total_entities(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_entities_ = value;
}

// uint32 wayland_apps = 2;
inline void EngineStatus::clear_wayland_apps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_apps_ = 0u;
}
inline ::uint32_t EngineStatus::wayland_apps() const {
  // @@protoc_insertion_point(field_get:EngineStatus.wayland_apps)
  return _internal_wayland_apps();
}
inline void EngineStatus::set_wayland_apps(::uint32_t value) {
  _internal_set_wayland_apps(value);
  // @@protoc_insertion_point(field_set:EngineStatus.wayland_apps)
}
inline ::uint32_t EngineStatus::_internal_wayland_apps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wayland_apps_;
}
inline void EngineStatus::_internal_set_wayland_apps(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_apps_ = value;
}

// bool wayland_focus = 3;
inline void EngineStatus::clear_wayland_focus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_focus_ = false;
}
inline bool EngineStatus::wayland_focus() const {
  // @@protoc_insertion_point(field_get:EngineStatus.wayland_focus)
  return _internal_wayland_focus();
}
inline void EngineStatus::set_wayland_focus(bool value) {
  _internal_set_wayland_focus(value);
  // @@protoc_insertion_point(field_set:EngineStatus.wayland_focus)
}
inline bool EngineStatus::_internal_wayland_focus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wayland_focus_;
}
inline void EngineStatus::_internal_set_wayland_focus(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_focus_ = value;
}

// .Vector camera_position = 4;
inline bool EngineStatus::has_camera_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_position_ != nullptr);
  return value;
}
inline void EngineStatus::clear_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.camera_position_ != nullptr) _impl_.camera_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Vector& EngineStatus::_internal_camera_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.camera_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& EngineStatus::camera_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:EngineStatus.camera_position)
  return _internal_camera_position();
}
inline void EngineStatus::unsafe_arena_set_allocated_camera_position(::Vector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.camera_position_);
  }
  _impl_.camera_position_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EngineStatus.camera_position)
}
inline ::Vector* EngineStatus::release_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* released = _impl_.camera_position_;
  _impl_.camera_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Vector* EngineStatus::unsafe_arena_release_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:EngineStatus.camera_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Vector* temp = _impl_.camera_position_;
  _impl_.camera_position_ = nullptr;
  return temp;
}
inline ::Vector* EngineStatus::_internal_mutable_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.camera_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.camera_position_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.camera_position_;
}
inline ::Vector* EngineStatus::mutable_camera_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Vector* _msg = _internal_mutable_camera_position();
  // @@protoc_insertion_point(field_mutable:EngineStatus.camera_position)
  return _msg;
}
inline void EngineStatus::set_allocated_camera_position(::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.camera_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.camera_position_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:EngineStatus.camera_position)
}

// -------------------------------------------------------------------

// Move

// float xDelta = 1;
inline void Move::clear_xdelta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xdelta_ = 0;
}
inline float Move::xdelta() const {
  // @@protoc_insertion_point(field_get:Move.xDelta)
  return _internal_xdelta();
}
inline void Move::set_xdelta(float value) {
  _internal_set_xdelta(value);
  // @@protoc_insertion_point(field_set:Move.xDelta)
}
inline float Move::_internal_xdelta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.xdelta_;
}
inline void Move::_internal_set_xdelta(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xdelta_ = value;
}

// float yDelta = 2;
inline void Move::clear_ydelta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ydelta_ = 0;
}
inline float Move::ydelta() const {
  // @@protoc_insertion_point(field_get:Move.yDelta)
  return _internal_ydelta();
}
inline void Move::set_ydelta(float value) {
  _internal_set_ydelta(value);
  // @@protoc_insertion_point(field_set:Move.yDelta)
}
inline float Move::_internal_ydelta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ydelta_;
}
inline void Move::_internal_set_ydelta(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ydelta_ = value;
}

// float zDelta = 3;
inline void Move::clear_zdelta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zdelta_ = 0;
}
inline float Move::zdelta() const {
  // @@protoc_insertion_point(field_get:Move.zDelta)
  return _internal_zdelta();
}
inline void Move::set_zdelta(float value) {
  _internal_set_zdelta(value);
  // @@protoc_insertion_point(field_set:Move.zDelta)
}
inline float Move::_internal_zdelta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.zdelta_;
}
inline void Move::_internal_set_zdelta(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zdelta_ = value;
}

// float unitsPerSecond = 4;
inline void Move::clear_unitspersecond() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = 0;
}
inline float Move::unitspersecond() const {
  // @@protoc_insertion_point(field_get:Move.unitsPerSecond)
  return _internal_unitspersecond();
}
inline void Move::set_unitspersecond(float value) {
  _internal_set_unitspersecond(value);
  // @@protoc_insertion_point(field_set:Move.unitsPerSecond)
}
inline float Move::_internal_unitspersecond() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unitspersecond_;
}
inline void Move::_internal_set_unitspersecond(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = value;
}

// -------------------------------------------------------------------

// TurnKey

// bool on = 2;
inline void TurnKey::clear_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_ = false;
}
inline bool TurnKey::on() const {
  // @@protoc_insertion_point(field_get:TurnKey.on)
  return _internal_on();
}
inline void TurnKey::set_on(bool value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:TurnKey.on)
}
inline bool TurnKey::_internal_on() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_;
}
inline void TurnKey::_internal_set_on(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_ = value;
}

// -------------------------------------------------------------------

// ApiRequest

// int64 entityId = 1;
inline void ApiRequest::clear_entityid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = ::int64_t{0};
}
inline ::int64_t ApiRequest::entityid() const {
  // @@protoc_insertion_point(field_get:ApiRequest.entityId)
  return _internal_entityid();
}
inline void ApiRequest::set_entityid(::int64_t value) {
  _internal_set_entityid(value);
  // @@protoc_insertion_point(field_set:ApiRequest.entityId)
}
inline ::int64_t ApiRequest::_internal_entityid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entityid_;
}
inline void ApiRequest::_internal_set_entityid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = value;
}

// .MessageType type = 2;
inline void ApiRequest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::MessageType ApiRequest::type() const {
  // @@protoc_insertion_point(field_get:ApiRequest.type)
  return _internal_type();
}
inline void ApiRequest::set_type(::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ApiRequest.type)
}
inline ::MessageType ApiRequest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::MessageType>(_impl_.type_);
}
inline void ApiRequest::_internal_set_type(::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .Move move = 3;
inline bool ApiRequest::has_move() const {
  return payload_case() == kMove;
}
inline bool ApiRequest::_internal_has_move() const {
  return payload_case() == kMove;
}
inline void ApiRequest::set_has_move() {
  _impl_._oneof_case_[0] = kMove;
}
inline void ApiRequest::clear_move() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kMove) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.move_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.move_);
    }
    clear_has_payload();
  }
}
inline ::Move* ApiRequest::release_move() {
  // @@protoc_insertion_point(field_release:ApiRequest.move)
  if (payload_case() == kMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Move& ApiRequest::_internal_move() const {
  return payload_case() == kMove ? *_impl_.payload_.move_ : reinterpret_cast<::Move&>(::_Move_default_instance_);
}
inline const ::Move& ApiRequest::move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.move)
  return _internal_move();
}
inline ::Move* ApiRequest::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.move)
  if (payload_case() == kMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_;
    _impl_.payload_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_move(::Move* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_move();
    _impl_.payload_.move_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.move)
}
inline ::Move* ApiRequest::_internal_mutable_move() {
  if (payload_case() != kMove) {
    clear_payload();
    set_has_move();
    _impl_.payload_.move_ =
        ::google::protobuf::Message::DefaultConstruct<::Move>(GetArena());
  }
  return _impl_.payload_.move_;
}
inline ::Move* ApiRequest::mutable_move() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Move* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:ApiRequest.move)
  return _msg;
}

// .TurnKey turnKey = 4;
inline bool ApiRequest::has_turnkey() const {
  return payload_case() == kTurnKey;
}
inline bool ApiRequest::_internal_has_turnkey() const {
  return payload_case() == kTurnKey;
}
inline void ApiRequest::set_has_turnkey() {
  _impl_._oneof_case_[0] = kTurnKey;
}
inline void ApiRequest::clear_turnkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kTurnKey) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.turnkey_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.turnkey_);
    }
    clear_has_payload();
  }
}
inline ::TurnKey* ApiRequest::release_turnkey() {
  // @@protoc_insertion_point(field_release:ApiRequest.turnKey)
  if (payload_case() == kTurnKey) {
    clear_has_payload();
    auto* temp = _impl_.payload_.turnkey_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.turnkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TurnKey& ApiRequest::_internal_turnkey() const {
  return payload_case() == kTurnKey ? *_impl_.payload_.turnkey_ : reinterpret_cast<::TurnKey&>(::_TurnKey_default_instance_);
}
inline const ::TurnKey& ApiRequest::turnkey() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.turnKey)
  return _internal_turnkey();
}
inline ::TurnKey* ApiRequest::unsafe_arena_release_turnkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.turnKey)
  if (payload_case() == kTurnKey) {
    clear_has_payload();
    auto* temp = _impl_.payload_.turnkey_;
    _impl_.payload_.turnkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_turnkey(::TurnKey* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_turnkey();
    _impl_.payload_.turnkey_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.turnKey)
}
inline ::TurnKey* ApiRequest::_internal_mutable_turnkey() {
  if (payload_case() != kTurnKey) {
    clear_payload();
    set_has_turnkey();
    _impl_.payload_.turnkey_ =
        ::google::protobuf::Message::DefaultConstruct<::TurnKey>(GetArena());
  }
  return _impl_.payload_.turnkey_;
}
inline ::TurnKey* ApiRequest::mutable_turnkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TurnKey* _msg = _internal_mutable_turnkey();
  // @@protoc_insertion_point(field_mutable:ApiRequest.turnKey)
  return _msg;
}

// .PlayerMove playerMove = 5;
inline bool ApiRequest::has_playermove() const {
  return payload_case() == kPlayerMove;
}
inline bool ApiRequest::_internal_has_playermove() const {
  return payload_case() == kPlayerMove;
}
inline void ApiRequest::set_has_playermove() {
  _impl_._oneof_case_[0] = kPlayerMove;
}
inline void ApiRequest::clear_playermove() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPlayerMove) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.playermove_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.playermove_);
    }
    clear_has_payload();
  }
}
inline ::PlayerMove* ApiRequest::release_playermove() {
  // @@protoc_insertion_point(field_release:ApiRequest.playerMove)
  if (payload_case() == kPlayerMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.playermove_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.playermove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PlayerMove& ApiRequest::_internal_playermove() const {
  return payload_case() == kPlayerMove ? *_impl_.payload_.playermove_ : reinterpret_cast<::PlayerMove&>(::_PlayerMove_default_instance_);
}
inline const ::PlayerMove& ApiRequest::playermove() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.playerMove)
  return _internal_playermove();
}
inline ::PlayerMove* ApiRequest::unsafe_arena_release_playermove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.playerMove)
  if (payload_case() == kPlayerMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.playermove_;
    _impl_.payload_.playermove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_playermove(::PlayerMove* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_playermove();
    _impl_.payload_.playermove_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.playerMove)
}
inline ::PlayerMove* ApiRequest::_internal_mutable_playermove() {
  if (payload_case() != kPlayerMove) {
    clear_payload();
    set_has_playermove();
    _impl_.payload_.playermove_ =
        ::google::protobuf::Message::DefaultConstruct<::PlayerMove>(GetArena());
  }
  return _impl_.payload_.playermove_;
}
inline ::PlayerMove* ApiRequest::mutable_playermove() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PlayerMove* _msg = _internal_mutable_playermove();
  // @@protoc_insertion_point(field_mutable:ApiRequest.playerMove)
  return _msg;
}

// .NoPayload noPayload = 6;
inline bool ApiRequest::has_nopayload() const {
  return payload_case() == kNoPayload;
}
inline bool ApiRequest::_internal_has_nopayload() const {
  return payload_case() == kNoPayload;
}
inline void ApiRequest::set_has_nopayload() {
  _impl_._oneof_case_[0] = kNoPayload;
}
inline void ApiRequest::clear_nopayload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kNoPayload) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.nopayload_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.nopayload_);
    }
    clear_has_payload();
  }
}
inline ::NoPayload* ApiRequest::release_nopayload() {
  // @@protoc_insertion_point(field_release:ApiRequest.noPayload)
  if (payload_case() == kNoPayload) {
    clear_has_payload();
    auto* temp = _impl_.payload_.nopayload_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nopayload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::NoPayload& ApiRequest::_internal_nopayload() const {
  return payload_case() == kNoPayload ? *_impl_.payload_.nopayload_ : reinterpret_cast<::NoPayload&>(::_NoPayload_default_instance_);
}
inline const ::NoPayload& ApiRequest::nopayload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.noPayload)
  return _internal_nopayload();
}
inline ::NoPayload* ApiRequest::unsafe_arena_release_nopayload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.noPayload)
  if (payload_case() == kNoPayload) {
    clear_has_payload();
    auto* temp = _impl_.payload_.nopayload_;
    _impl_.payload_.nopayload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_nopayload(::NoPayload* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_nopayload();
    _impl_.payload_.nopayload_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.noPayload)
}
inline ::NoPayload* ApiRequest::_internal_mutable_nopayload() {
  if (payload_case() != kNoPayload) {
    clear_payload();
    set_has_nopayload();
    _impl_.payload_.nopayload_ =
        ::google::protobuf::Message::DefaultConstruct<::NoPayload>(GetArena());
  }
  return _impl_.payload_.nopayload_;
}
inline ::NoPayload* ApiRequest::mutable_nopayload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::NoPayload* _msg = _internal_mutable_nopayload();
  // @@protoc_insertion_point(field_mutable:ApiRequest.noPayload)
  return _msg;
}

// .AddVoxels addVoxels = 7;
inline bool ApiRequest::has_addvoxels() const {
  return payload_case() == kAddVoxels;
}
inline bool ApiRequest::_internal_has_addvoxels() const {
  return payload_case() == kAddVoxels;
}
inline void ApiRequest::set_has_addvoxels() {
  _impl_._oneof_case_[0] = kAddVoxels;
}
inline void ApiRequest::clear_addvoxels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kAddVoxels) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.addvoxels_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.addvoxels_);
    }
    clear_has_payload();
  }
}
inline ::AddVoxels* ApiRequest::release_addvoxels() {
  // @@protoc_insertion_point(field_release:ApiRequest.addVoxels)
  if (payload_case() == kAddVoxels) {
    clear_has_payload();
    auto* temp = _impl_.payload_.addvoxels_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.addvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AddVoxels& ApiRequest::_internal_addvoxels() const {
  return payload_case() == kAddVoxels ? *_impl_.payload_.addvoxels_ : reinterpret_cast<::AddVoxels&>(::_AddVoxels_default_instance_);
}
inline const ::AddVoxels& ApiRequest::addvoxels() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.addVoxels)
  return _internal_addvoxels();
}
inline ::AddVoxels* ApiRequest::unsafe_arena_release_addvoxels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.addVoxels)
  if (payload_case() == kAddVoxels) {
    clear_has_payload();
    auto* temp = _impl_.payload_.addvoxels_;
    _impl_.payload_.addvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_addvoxels(::AddVoxels* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_addvoxels();
    _impl_.payload_.addvoxels_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.addVoxels)
}
inline ::AddVoxels* ApiRequest::_internal_mutable_addvoxels() {
  if (payload_case() != kAddVoxels) {
    clear_payload();
    set_has_addvoxels();
    _impl_.payload_.addvoxels_ =
        ::google::protobuf::Message::DefaultConstruct<::AddVoxels>(GetArena());
  }
  return _impl_.payload_.addvoxels_;
}
inline ::AddVoxels* ApiRequest::mutable_addvoxels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AddVoxels* _msg = _internal_mutable_addvoxels();
  // @@protoc_insertion_point(field_mutable:ApiRequest.addVoxels)
  return _msg;
}

// .ClearVoxels clearVoxels = 8;
inline bool ApiRequest::has_clearvoxels() const {
  return payload_case() == kClearVoxels;
}
inline bool ApiRequest::_internal_has_clearvoxels() const {
  return payload_case() == kClearVoxels;
}
inline void ApiRequest::set_has_clearvoxels() {
  _impl_._oneof_case_[0] = kClearVoxels;
}
inline void ApiRequest::clear_clearvoxels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kClearVoxels) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.clearvoxels_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.clearvoxels_);
    }
    clear_has_payload();
  }
}
inline ::ClearVoxels* ApiRequest::release_clearvoxels() {
  // @@protoc_insertion_point(field_release:ApiRequest.clearVoxels)
  if (payload_case() == kClearVoxels) {
    clear_has_payload();
    auto* temp = _impl_.payload_.clearvoxels_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.clearvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClearVoxels& ApiRequest::_internal_clearvoxels() const {
  return payload_case() == kClearVoxels ? *_impl_.payload_.clearvoxels_ : reinterpret_cast<::ClearVoxels&>(::_ClearVoxels_default_instance_);
}
inline const ::ClearVoxels& ApiRequest::clearvoxels() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.clearVoxels)
  return _internal_clearvoxels();
}
inline ::ClearVoxels* ApiRequest::unsafe_arena_release_clearvoxels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.clearVoxels)
  if (payload_case() == kClearVoxels) {
    clear_has_payload();
    auto* temp = _impl_.payload_.clearvoxels_;
    _impl_.payload_.clearvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_clearvoxels(::ClearVoxels* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_clearvoxels();
    _impl_.payload_.clearvoxels_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.clearVoxels)
}
inline ::ClearVoxels* ApiRequest::_internal_mutable_clearvoxels() {
  if (payload_case() != kClearVoxels) {
    clear_payload();
    set_has_clearvoxels();
    _impl_.payload_.clearvoxels_ =
        ::google::protobuf::Message::DefaultConstruct<::ClearVoxels>(GetArena());
  }
  return _impl_.payload_.clearvoxels_;
}
inline ::ClearVoxels* ApiRequest::mutable_clearvoxels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ClearVoxels* _msg = _internal_mutable_clearvoxels();
  // @@protoc_insertion_point(field_mutable:ApiRequest.clearVoxels)
  return _msg;
}

// .ConfirmAction confirmAction = 9;
inline bool ApiRequest::has_confirmaction() const {
  return payload_case() == kConfirmAction;
}
inline bool ApiRequest::_internal_has_confirmaction() const {
  return payload_case() == kConfirmAction;
}
inline void ApiRequest::set_has_confirmaction() {
  _impl_._oneof_case_[0] = kConfirmAction;
}
inline void ApiRequest::clear_confirmaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kConfirmAction) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.confirmaction_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.confirmaction_);
    }
    clear_has_payload();
  }
}
inline ::ConfirmAction* ApiRequest::release_confirmaction() {
  // @@protoc_insertion_point(field_release:ApiRequest.confirmAction)
  if (payload_case() == kConfirmAction) {
    clear_has_payload();
    auto* temp = _impl_.payload_.confirmaction_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.confirmaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ConfirmAction& ApiRequest::_internal_confirmaction() const {
  return payload_case() == kConfirmAction ? *_impl_.payload_.confirmaction_ : reinterpret_cast<::ConfirmAction&>(::_ConfirmAction_default_instance_);
}
inline const ::ConfirmAction& ApiRequest::confirmaction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.confirmAction)
  return _internal_confirmaction();
}
inline ::ConfirmAction* ApiRequest::unsafe_arena_release_confirmaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.confirmAction)
  if (payload_case() == kConfirmAction) {
    clear_has_payload();
    auto* temp = _impl_.payload_.confirmaction_;
    _impl_.payload_.confirmaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_confirmaction(::ConfirmAction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_confirmaction();
    _impl_.payload_.confirmaction_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.confirmAction)
}
inline ::ConfirmAction* ApiRequest::_internal_mutable_confirmaction() {
  if (payload_case() != kConfirmAction) {
    clear_payload();
    set_has_confirmaction();
    _impl_.payload_.confirmaction_ =
        ::google::protobuf::Message::DefaultConstruct<::ConfirmAction>(GetArena());
  }
  return _impl_.payload_.confirmaction_;
}
inline ::ConfirmAction* ApiRequest::mutable_confirmaction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ConfirmAction* _msg = _internal_mutable_confirmaction();
  // @@protoc_insertion_point(field_mutable:ApiRequest.confirmAction)
  return _msg;
}

// .KeyReplay keyReplay = 10;
inline bool ApiRequest::has_keyreplay() const {
  return payload_case() == kKeyReplay;
}
inline bool ApiRequest::_internal_has_keyreplay() const {
  return payload_case() == kKeyReplay;
}
inline void ApiRequest::set_has_keyreplay() {
  _impl_._oneof_case_[0] = kKeyReplay;
}
inline void ApiRequest::clear_keyreplay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kKeyReplay) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.keyreplay_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.keyreplay_);
    }
    clear_has_payload();
  }
}
inline ::KeyReplay* ApiRequest::release_keyreplay() {
  // @@protoc_insertion_point(field_release:ApiRequest.keyReplay)
  if (payload_case() == kKeyReplay) {
    clear_has_payload();
    auto* temp = _impl_.payload_.keyreplay_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.keyreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KeyReplay& ApiRequest::_internal_keyreplay() const {
  return payload_case() == kKeyReplay ? *_impl_.payload_.keyreplay_ : reinterpret_cast<::KeyReplay&>(::_KeyReplay_default_instance_);
}
inline const ::KeyReplay& ApiRequest::keyreplay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.keyReplay)
  return _internal_keyreplay();
}
inline ::KeyReplay* ApiRequest::unsafe_arena_release_keyreplay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.keyReplay)
  if (payload_case() == kKeyReplay) {
    clear_has_payload();
    auto* temp = _impl_.payload_.keyreplay_;
    _impl_.payload_.keyreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_keyreplay(::KeyReplay* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_keyreplay();
    _impl_.payload_.keyreplay_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.keyReplay)
}
inline ::KeyReplay* ApiRequest::_internal_mutable_keyreplay() {
  if (payload_case() != kKeyReplay) {
    clear_payload();
    set_has_keyreplay();
    _impl_.payload_.keyreplay_ =
        ::google::protobuf::Message::DefaultConstruct<::KeyReplay>(GetArena());
  }
  return _impl_.payload_.keyreplay_;
}
inline ::KeyReplay* ApiRequest::mutable_keyreplay() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KeyReplay* _msg = _internal_mutable_keyreplay();
  // @@protoc_insertion_point(field_mutable:ApiRequest.keyReplay)
  return _msg;
}

// .PointerReplay pointerReplay = 11;
inline bool ApiRequest::has_pointerreplay() const {
  return payload_case() == kPointerReplay;
}
inline bool ApiRequest::_internal_has_pointerreplay() const {
  return payload_case() == kPointerReplay;
}
inline void ApiRequest::set_has_pointerreplay() {
  _impl_._oneof_case_[0] = kPointerReplay;
}
inline void ApiRequest::clear_pointerreplay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPointerReplay) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.pointerreplay_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.pointerreplay_);
    }
    clear_has_payload();
  }
}
inline ::PointerReplay* ApiRequest::release_pointerreplay() {
  // @@protoc_insertion_point(field_release:ApiRequest.pointerReplay)
  if (payload_case() == kPointerReplay) {
    clear_has_payload();
    auto* temp = _impl_.payload_.pointerreplay_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.pointerreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PointerReplay& ApiRequest::_internal_pointerreplay() const {
  return payload_case() == kPointerReplay ? *_impl_.payload_.pointerreplay_ : reinterpret_cast<::PointerReplay&>(::_PointerReplay_default_instance_);
}
inline const ::PointerReplay& ApiRequest::pointerreplay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.pointerReplay)
  return _internal_pointerreplay();
}
inline ::PointerReplay* ApiRequest::unsafe_arena_release_pointerreplay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.pointerReplay)
  if (payload_case() == kPointerReplay) {
    clear_has_payload();
    auto* temp = _impl_.payload_.pointerreplay_;
    _impl_.payload_.pointerreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_pointerreplay(::PointerReplay* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_pointerreplay();
    _impl_.payload_.pointerreplay_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.pointerReplay)
}
inline ::PointerReplay* ApiRequest::_internal_mutable_pointerreplay() {
  if (payload_case() != kPointerReplay) {
    clear_payload();
    set_has_pointerreplay();
    _impl_.payload_.pointerreplay_ =
        ::google::protobuf::Message::DefaultConstruct<::PointerReplay>(GetArena());
  }
  return _impl_.payload_.pointerreplay_;
}
inline ::PointerReplay* ApiRequest::mutable_pointerreplay() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PointerReplay* _msg = _internal_mutable_pointerreplay();
  // @@protoc_insertion_point(field_mutable:ApiRequest.pointerReplay)
  return _msg;
}

inline bool ApiRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ApiRequest::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ApiRequest::PayloadCase ApiRequest::payload_case() const {
  return ApiRequest::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ApiRequestResponse

// int64 requestId = 1;
inline void ApiRequestResponse::clear_requestid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requestid_ = ::int64_t{0};
}
inline ::int64_t ApiRequestResponse::requestid() const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.requestId)
  return _internal_requestid();
}
inline void ApiRequestResponse::set_requestid(::int64_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.requestId)
}
inline ::int64_t ApiRequestResponse::_internal_requestid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requestid_;
}
inline void ApiRequestResponse::_internal_set_requestid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requestid_ = value;
}

// int64 actionId = 2;
inline void ApiRequestResponse::clear_actionid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = ::int64_t{0};
}
inline ::int64_t ApiRequestResponse::actionid() const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.actionId)
  return _internal_actionid();
}
inline void ApiRequestResponse::set_actionid(::int64_t value) {
  _internal_set_actionid(value);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.actionId)
}
inline ::int64_t ApiRequestResponse::_internal_actionid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actionid_;
}
inline void ApiRequestResponse::_internal_set_actionid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = value;
}

// bool success = 3;
inline void ApiRequestResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool ApiRequestResponse::success() const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.success)
  return _internal_success();
}
inline void ApiRequestResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.success)
}
inline bool ApiRequestResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ApiRequestResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .EngineStatus status = 4;
inline bool ApiRequestResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ApiRequestResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::EngineStatus& ApiRequestResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::EngineStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::EngineStatus&>(::_EngineStatus_default_instance_);
}
inline const ::EngineStatus& ApiRequestResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.status)
  return _internal_status();
}
inline void ApiRequestResponse::unsafe_arena_set_allocated_status(::EngineStatus* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::EngineStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequestResponse.status)
}
inline ::EngineStatus* ApiRequestResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::EngineStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::EngineStatus* ApiRequestResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApiRequestResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::EngineStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::EngineStatus* ApiRequestResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::EngineStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::EngineStatus*>(p);
  }
  return _impl_.status_;
}
inline ::EngineStatus* ApiRequestResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::EngineStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ApiRequestResponse.status)
  return _msg;
}
inline void ApiRequestResponse::set_allocated_status(::EngineStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::EngineStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:ApiRequestResponse.status)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MessageType>() {
  return ::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_protos_2fapi_2eproto_2epb_2eh
